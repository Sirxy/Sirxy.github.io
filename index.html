<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="小白指路">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/">Hexo-沐雨橙风</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-03T03:06:37.000Z"><a href="/2019/04/03/HTTP学习01/">2019-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/03/HTTP学习01/">HTTP协议简介</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="一、Web服务基础"><a href="#一、Web服务基础" class="headerlink" title="一、Web服务基础"></a>一、Web服务基础</h3><p>用户访问网站的基本流程：<br>1、双击浏览器，输入<a href="http://www.baidu.com网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在www.baidu.com域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用" target="_blank" rel="noopener">www.baidu.com网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在www.baidu.com域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用</a><br>2、如果本地dns缓存和hosts文件都没有域名解析记录，系统就会把访问的网址解析请求发送给客户端设置的DNS服务器去解析，也叫做Local DNS，如果LDNS服务器的本地缓存有对应的解析记录就会直接返回给客户端IP地址，如果没有LDNS就会继续请求其他的DNS服务器<br>3、LDNS继续从DNS系统的”.”(根)开始请求<a href="http://www.baidu.com域名的解析，并且根据每个层级的DNS服务器系统进行系列的查找，最终在DNS网络上找到www.baidu.com域名对应的授权DNS服务器。这个授权DNS服务器就是企业（个人）购买域名时用于管理域名解析的服务器，服务器上有对应的域名（IP）解析。" target="_blank" rel="noopener">www.baidu.com域名的解析，并且根据每个层级的DNS服务器系统进行系列的查找，最终在DNS网络上找到www.baidu.com域名对应的授权DNS服务器。这个授权DNS服务器就是企业（个人）购买域名时用于管理域名解析的服务器，服务器上有对应的域名（IP）解析。</a><br>4、此时授权的DNS服务器就会把<a href="http://www.baidu.com对应的IP解析记录，例如（1.1.1.1）发送给LDNS" target="_blank" rel="noopener">www.baidu.com对应的IP解析记录，例如（1.1.1.1）发送给LDNS</a><br>5、此时LDNS会把解析记录发给浏览器，并且缓存域名和IP的解析记录，便于下一次更快的返回请求<br>6、浏览器获得ip，请求对应的服务器，网站服务器接收到客户端的请求开始响应处理，将内容返回给浏览器。</p>
<h3 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h3><p>全称是HyperText Tansfer Protocol,中文叫超文本传输协议，是互联网最常见的协议。<br>Http最重要的是www(World Wide Web)服务，也叫web服务器，中文叫“万维网”。<br>web服务端口默认是80，另外一个加密的www服务应用https默认端口是443，主要用于支付，网银相关业务。</p>
<h3 id="三、HTTP协议的特点"><a href="#三、HTTP协议的特点" class="headerlink" title="三、HTTP协议的特点"></a>三、HTTP协议的特点</h3><p>　　1.HTTP协议是无状态的<br>　　就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。</p>
<p>　　2.多次HTTP请求<br>　　在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。</p>
<p>　　3.基于TCP协议<br>　　HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。</p>
<h3 id="四、版本"><a href="#四、版本" class="headerlink" title="四、版本"></a>四、版本</h3><pre><code>http协议诞生以来有若干个版本，主要是http/1.0 http/1.1
http/1.0规定浏览器和服务器只能保持短暂的连接，浏览器的每次请求都需要和服务器建立一个TCP连接，服务器完成请求后即断开TCP连接，服务器不跟踪每个链接，也不记录请求
http/1.1是对HTTP的缺陷进行重点修复，从可扩展性，缓存，带宽优化，持久连接，host头，错误通知等访问改进。
http/1.1支持长连接，增加了更多的请求头和响应头信息，例如配置请求头的Connection的值为keep-alive，表示请求结果返回后保持连接
</code></pre><h3 id="五、Http请求方法"><a href="#五、Http请求方法" class="headerlink" title="五、Http请求方法"></a>五、Http请求方法</h3><pre><code>在HTTP通信中，每个请求报文都包含一个方法，以告诉web服务器端需要执行哪些操作，这些动作被称为HTTP的请求方法。
GET    请求指定的页面信息，并返回实体主体。
HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT    从客户端向服务器传送的数据取代指定的文档的内容。
DELETE    请求服务器删除指定的页面。
CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS    允许客户端查看服务器的性能。
TRACE    回显服务器收到的请求，主要用于测试或诊断。
</code></pre><h3 id="六、HTTP状态码"><a href="#六、HTTP状态码" class="headerlink" title="六、HTTP状态码"></a>六、HTTP状态码</h3><pre><code>HTTP状态码表示web服务器响应http请求状态的数字代码。
常见状态码以及作用：
1**    信息，服务器收到请求，需要请求者继续执行操作
2**    成功，操作被成功接收并处理
3**    重定向，需要进一步的操作以完成请求
4**    客户端错误，请求包含语法错误或无法完成请求
5**    服务器错误，服务器在处理请求的过程中发生了错误
</code></pre><h3 id="七、HTTP状态码的命令查看"><a href="#七、HTTP状态码的命令查看" class="headerlink" title="七、HTTP状态码的命令查看"></a>七、HTTP状态码的命令查看</h3><pre><code>$ curl -I www.oldboyedu.com
</code></pre><ul>
<li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a><pre><code>https://www.cnblogs.com/wxisme/p/6212797.html
</code></pre></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-03T01:31:41.000Z"><a href="/2019/04/03/nginx学习总结03/">2019-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/03/nginx学习总结03/">nginx多个虚拟主机</a></h1>
  

    </header>
    <div class="entry">
      
        <p>## </p>
<h3 id="Nginx多个虚拟主机"><a href="#Nginx多个虚拟主机" class="headerlink" title="Nginx多个虚拟主机"></a>Nginx多个虚拟主机</h3><p>想象一下，如果网站部署者在部署网站时，每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。于是就有了解决这种局面的办法：虚拟主机。虚拟主机就是将一台服务器分割成了多个“虚拟服务器”，每个站点可以使用各自的硬盘空间，由于节省资源、省钱，许多网站使用虚拟主机来部署网站。虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。</p>
<h4 id="虚拟主机类型"><a href="#虚拟主机类型" class="headerlink" title="虚拟主机类型"></a>虚拟主机类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 基于域名的虚拟主机</span><br><span class="line">通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。</span><br><span class="line"></span><br><span class="line">- 基于端口的虚拟主机</span><br><span class="line">通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000</span><br><span class="line"></span><br><span class="line">- 基于IP的虚拟主机</span><br><span class="line">通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP</span><br></pre></td></tr></table></figure>
<p>nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。<br>/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果。</p>
<p>修改nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">#配置文件内容如下</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #虚拟主机1</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pyyuc.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    #虚拟主机2</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pythonav;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn</span><br><span class="line">&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内</span><br><span class="line">[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn</span><br><span class="line">&lt;meta charset=utf8&gt;我是pyyuc站点</span><br></pre></td></tr></table></figure>
<ul>
<li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-03T00:52:04.000Z"><a href="/2019/04/03/nginx学习总结02/">2019-04-03</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/03/nginx学习总结02/">nginx目录、部署站点</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="一、nginx软件目录"><a href="#一、nginx软件目录" class="headerlink" title="一、nginx软件目录"></a>一、nginx软件目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yc-virtual-machine /opt/nginx1-12 11:44:02]#ls</span><br><span class="line">client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp</span><br></pre></td></tr></table></figure>
<ul>
<li>conf 存放nginx所有配置文件的目录,主要nginx.conf</li>
<li>html 存放nginx默认站点的目录，如index.html、error.html等</li>
<li>logs 存放nginx默认日志的目录，如error.log access.log</li>
<li>sbin 存放nginx主命令的目录,sbin/nginx</li>
</ul>
<p>Nginx主配置文件/etc/nginx/nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号{}来表示开始与结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CoreModule核心模块</span><br><span class="line"></span><br><span class="line">user www;                       #Nginx进程所使用的用户</span><br><span class="line">worker_processes 1;             #Nginx运行的work进程数量(建议与CPU数量一致或auto)</span><br><span class="line">error_log /log/nginx/error.log  #Nginx错误日志存放路径</span><br><span class="line">pid /var/run/nginx.pid          #Nginx服务运行后产生的pid进程号</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events事件模块</span><br><span class="line"></span><br><span class="line">events &#123;            </span><br><span class="line">    worker_connections  //每个worker进程支持的最大连接数</span><br><span class="line">    use epool;          //事件驱动模型, epoll默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http内核模块</span><br><span class="line"></span><br><span class="line">// 公共的配置定义在http&#123;&#125;</span><br><span class="line">http &#123;  //http层开始</span><br><span class="line">...    </span><br><span class="line">    // 使用Server配置网站, 每个Server&#123;&#125;代表一个网站(简称虚拟主机)</span><br><span class="line">    &apos;server&apos; &#123;</span><br><span class="line">        listen       80;        // 监听端口, 默认80</span><br><span class="line">        server_name  localhost; // 提供服务的域名或主机名</span><br><span class="line">        access_log host.access.log  // 访问日志</span><br><span class="line">        // 控制网站访问路径</span><br><span class="line">        &apos;location&apos; / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;   // 存放网站代码路径</span><br><span class="line">            index  index.html index.htm;    // 服务器返回的默认页面文件</span><br><span class="line">        &#125;</span><br><span class="line">        // 指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    //第二个虚拟主机配置</span><br><span class="line">    &apos;server&apos; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;  // 包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件</span><br><span class="line">&#125;   // http层结束</span><br></pre></td></tr></table></figure>
<h3 id="二、部署nginx站点"><a href="#二、部署nginx站点" class="headerlink" title="二、部署nginx站点"></a>二、部署nginx站点</h3><p>nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">        root   html;  #这里是默认的站点html文件夹，也就是              /opt/nginx1-12/html/文件夹下的内容</span><br><span class="line">        index  index.html index.htm; #站点首页文件名是index.html</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yc-virtual-machine /tmp 11:34:52]#ls /opt/nginx1-12/html/</span><br><span class="line">index.html  jssts.jpeg  lhy.mp4  man.jpg  wget-log</span><br></pre></td></tr></table></figure></p>
<p>至此，只需要通过域名/资源，即可访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.pyyuc.cn/index.html</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-02T10:01:56.000Z"><a href="/2019/04/02/nginx学习总结01/">2019-04-02</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/02/nginx学习总结01/">nginx简介、安装</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="一、nginx出世"><a href="#一、nginx出世" class="headerlink" title="一、nginx出世"></a>一、nginx出世</h3><p>2004年10月4日，为俄罗斯知名门户站点而开发的Web服务程序 Nginx 横空出世。Nginx程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市场，但Nginx最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。</p>
<h3 id="二、nginx介绍"><a href="#二、nginx介绍" class="headerlink" title="二、nginx介绍"></a>二、nginx介绍</h3><ul>
<li>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。</li>
<li>nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。</li>
<li>nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。</li>
<li>安装更为简单，方便，灵活。</li>
<li>支持高并发，能支持几万并发连接</li>
<li>资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M</li>
<li>可以做http反向代理和负载均衡</li>
<li>支持异步网络i/o事件模型epoll<br>下面介绍nginx的安装与配置</li>
</ul>
<h3 id="三、安装配置nginx"><a href="#三、安装配置nginx" class="headerlink" title="三、安装配置nginx"></a>三、安装配置nginx</h3><h4 id="安装nginx前的依赖环境解决"><a href="#安装nginx前的依赖环境解决" class="headerlink" title="安装nginx前的依赖环境解决"></a>安装nginx前的依赖环境解决</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#执行第一条语句即可</span><br><span class="line">yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</span><br><span class="line">#依赖简单介绍</span><br><span class="line">一. gcc 安装</span><br><span class="line">安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</span><br><span class="line">yum install gcc-c++</span><br><span class="line">二. PCRE pcre-devel 安装</span><br><span class="line">PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">三. zlib 安装</span><br><span class="line">zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">四. OpenSSL 安装</span><br><span class="line">OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。</span><br><span class="line">nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</span><br></pre></td></tr></table></figure>
<h4 id="编译安装nginx"><a href="#编译安装nginx" class="headerlink" title="编译安装nginx"></a>编译安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.下载源码包</span><br><span class="line">wget -c https://nginx.org/download/nginx-1.12.0.tar.gz</span><br><span class="line">2.解压缩源码</span><br><span class="line">tar -zxvf nginx-1.12.0.tar.gz</span><br><span class="line">3.配置，编译安装  开启nginx状态监测功能</span><br><span class="line">./configure --prefix=/opt/nginx112/ </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line">4.启动nginx，进入sbin目录,找到nginx启动命令</span><br><span class="line">cd sbin</span><br><span class="line">./nginx #启动</span><br><span class="line">./nginx -s stop #关闭</span><br><span class="line">./nginx -s reload #重新加载</span><br><span class="line">5.修改PATH</span><br><span class="line">PATH=$PATH:/opt/nginx112/</span><br></pre></td></tr></table></figure>
<ul>
<li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-02-13T02:36:41.753Z"><a href="/2019/02/13/hello-world/">2019-02-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/02/13/hello-world/">Hello World</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-19T12:43:32.000Z"><a href="/2018/11/19/Linux基础/">2018-11-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/19/Linux基础/">Linux基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p>一、Linux与Windows的区别<br>体现在目录的结构和安全性上，Linux所有的命令是以文件形式存储的，在Linux系统当中一切皆为文件（常用的比如：普通文件、目录文件、链接文件、设备文件等）。</p>
<p>二、目录含义<br>/bin 存放普通用户的命令文件<br>/boot 存放系统启动文件<br>/cdrom 存放读取光盘<br>/dev 存放设备相关文件<br>/etc 存放配置文件<br>/home 家目录<br>/lib 库文件相关<br>/lib64 64位库文件<br>/lost+found 系统异常产生错误时，丢失文件放在这里<br>/media 媒体文件<br>/mnt 挂载目录<br>/opt 安装软件时的默认目录<br>/proc 内存中相关数据文件<br>/root root用户登录的家目录<br>/run 系统运行的时候用到的文件<br>/sbin 超级管理员运行的文件<br>/srv 服务启动之后需要访问的数据目录<br>/sys 系统文件<br>/tmp 临时文件<br>/usr 应用程序存放目录<br>/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件</p>
<p>三、相关命令<br>查看命令（目录结构、路径）：<br>.     当前路径<br>..  上一级路径<br>cd ..  回到上一级<br>cd  切换到家目录<br>cd ~  切换到家目录<br>cd - 回到上一个你操作的那一个目录<br>pwd 查看当前所在的目录是哪里<br>ls  查看当前文件夹里面有什么<br>    .bash_history 但凡是点开头的文件，都是隐藏文件<br>    -a  所有文件（包括隐藏文件）<br>    -l  以列表的形式呈现<br>    -h  可以让文件大小带上单位<br>ll 相当于ls -al<br>man 是帮助命令，比如：man ls或man cp<br>nano 内置自带的文本编辑器（编辑文件用的）<br>cat 查看文件内容<br>more 对于内容较多的情况下用more支持分页，空格下一页<br>head 加上-2是查看前几条<br>tail 加上-2是查看后几条<br>dmesg 查看系统接入设备信息<br>top 查看运行状态<br>sudo service network-manager restart 网络有线未托管<br>sudo apt-get install vim<br>操作命令（新建、复制粘贴剪切、删除）：<br>mkdir 要创建的文件夹名字<br>touch 要创建的文件名<br>ln -s 创建软链接，ln -s 指定你想要创建的连接  放到哪个目录下面，ln -s 需要使用绝对路径的方式来创建。<br>mv /路径/文件夹或文件 新名称  功能：既可以剪切也可以改名<br>cp 路径 路径（从哪里~到哪里去）<br>cp 默认只能够复制文件<br>cp -r 可以复制文件夹<br>cp -a 可以复制权限和所有属性<br>rm -rf 指定文件夹或者文件名称 功能：用于删除文件或者目录<br>查找命令（找文件、文件内容）：<br>find 搜索文件的命令<br>find 查找位置 -name 文件名<br>find    /     -iname index.php<br>grep 搜索文件里面符合条件的内容<br>grep “字符串” 文件名<br>grep  -i   “root”<br>grep  -v   “root”<br>挂载操作命令：<br>sudo fdisk -l         查看当前系统有哪些挂载设备<br>sudo mount 找到的设备路径 /mnt/cdrom           挂载<br>sudo umount /mnt/cdrom(umount + 挂载的目录)    取消挂载</p>
<p>四、权限结构<br>在Linux中，无论文件夹还是文件都是有权限的，通过在终端键入ls -l命令行可以看到每一行开始都有类似drwxrwxr-x的一串字符码，当中就包含有权限的标识。其中：第一位表示类型，即说明是文件夹(d)、文件(-)以及链接(l)中的哪一类型；后面的9位，每三位划分为一组作为权限位，从前往后这三个权限位分别标识所属主、所属组、其他用户的权限。<br>指定类型(dl-) 权限位1(rwx) 权限位2(rwx) 权限位3(rwx)，其中r=&gt;read w=&gt;write x=&gt;可执行，r =&gt; 4, w =&gt; 2, x =&gt; 1。<br>d rwx rwx r-x<br>文件类型-所属主 所属组 其他<br>   d     rwx     rwx    rwx<br>位数1,2,3 代表当前文件或者文件夹的所有者的权限设定:(所有者的权限  u,user)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>位数4,5,6 代表当前文件或者文件夹的所属组的权限设定:(所属组的权限 g ,group)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>位数7,8,9 代表其他用户对当前文件或者文件夹的的权限设定:(其他人的权限 o,other)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>更改权限<br>rwx的任意组合共 8 种 情况：<br>rwx    =&gt; 7<br>rw-    =&gt; 6<br>r-x    =&gt; 5<br>r–    =&gt; 4<br>-wx    =&gt; 3<br>-w-    =&gt; 2<br>–x    =&gt; 1<br>—    =&gt; 0<br>其中r =&gt; 4, w =&gt; 2, x =&gt; 1。例如：根目录下默认的文件夹权限为755（rwx  r-x  r-x） ，根目录下默认的文件权限为644（rw-  r–  r–），所有权限为777（rwx  rwx  rwx）<br>关于权限更改的各种写法<br>chmod 755 1.txt<br>chmod -R 777 ceshi100(chmod -R 777 文件夹) # 递归更改这个文件夹里面的所有文件权限<br>chmod u+r,g-w,o+x 1.txt<br>chmod u=rwx 1.txt<br>其中：<br>u代表所有者   加一个r权限 (user)<br>g代表所属组   减一个w权限 (group)<br>o代表其他     加一个执行权限 (other)<br>=&gt;对于目录来讲<br>r   是否呈现里面的文件<br>w   是否可以在里面创建文件或文件夹<br>x   cd 切不进来  不能访问这个目录<br>=&gt;对于文件来讲<br>r  可以看到文件内容<br>w  可以更改删除文件及内容<br>x  是否可以执行这个文件 ./abc.sh</p>
<p>(*扩展)<br>sudo useradd a01    添加新用户账号<br>sudo passwd a01     为新用户设置密码<br>sudo su a01            切换用户账号<br>exit                  退出当前用户  </p>
<p><a href="http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/" target="_blank" rel="noopener">http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-17T03:49:16.000Z"><a href="/2018/11/17/Python基础总结-md/">2018-11-17</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/17/Python基础总结-md/">Python基础总结.md</a></h1>
  

    </header>
    <div class="entry">
      
        <p>一、注释<br>1、 注释的排错性<br>    先注释一部分代码，然后执行另外一部分代码，查看报错，用于调试。<br>2、注释的注意点<br>    多行注释的嵌套：<br>        如果外面是三个单引号，则里面要用三个双引号；如果外面是三个双引号，则里面要用三个单引号。</p>
<p>二、变量<br>1、概念：可以改变的量，具体是指内存中的一段存储空间。<br>    house305 = “张三”<br>    print(house305)<br>    house305 = “李四”<br>    print(house305)<br>2、变量的三种声明方式：<br>    方式一<br>        a = 1<br>        b = 2<br>    方式二<br>        a, b = 1, 2<br>    方式三<br>        a = b = 3 (注意：这种方式的id(a) == id(b))</p>
<p>3、变量的命名规范：<br>字母数字下划线，首字母不能为数字。<br>严格区分大小写，且不能使用关键字。<br>变量命名有意义，且不能使用中文哦。<br>import keyword<br>print(keyword.kwlist) # [‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]<br>4、变量的交换<br>a = 3<br>b = 10<br>a, b = b, a<br>print(a, b) # 10 3</p>
<p>三、Python的六大数据类型<br>分为：Number型、容器类型（字符串型、列表型、元组型、集合型、字典型）。<br>(1)Number数字类型(int  float  bool  complex)<br>    ①Number类型之int 整型(正整数 0 负整数)<br>        intvar = 37<br>        print(intvar)</p>
<pre><code>    # type() 查看一个值的数据类型
    res = type(intvar)
    print(res) #&lt;class &apos;int&apos;&gt;
    # id() 查看一个变量所指向值的地址
    res = id(intvar)
    print(res)  #10915520

    # 二进制整型
    intvar = 0b1010101
    # 八进制整型
    intvar = 0o127
    # 十六进制整型
    intvar = 0xFF

    # 变量声明的第三种方式 特点
    a = b = 89
    res1 = id(a)
    res2 = id(b)
    print(res1)
    print(res2)
②Number类型之float 浮点型 （小数：1普通小数 2科学计数法表示的小数。例:a = 3e-5  #3e-05 ）
    (1)表示方式一
        floatvar = 3.14
    (2)表示方式二
        floatvar = 3.14e-2  # 小数点向左移动2位
        floatvar = 3.14e04  # 小数点向右移动4位
③Number类型之bool 布尔型 （True 真的 False 假的）
    boolvar = True
    boolvar = False    
④Number类型之complex 复数类型（实数+虚数 组成）
    ‘&apos;&apos; 如果有一个数，它的平方是-1，那么这个数就是j
        (科学家认为有，表达一个高精度的类型)
    &apos;&apos;&apos;
    (1) 表达方式一
        complexvar = 3 + 4j
        complexvar = 4j
    (2)表达方式二
        &apos;&apos;&apos; var1 = complex(实数,虚数)
            通过complex强制转换成复数类型
        &apos;&apos;&apos;
        complexvar = complex(3, 5)
</code></pre><p>（2）String字符串型<br>特征：可获取，不可修改的有序容器类型数据。</p>
<pre><code># error
strvar=&quot;这是真的字符串&quot;
strvar[-3] = &quot;假&quot;
print(strvar)
</code></pre><p>字符串有三种类型：通过单引号、双引号、三引号（可以支持跨行,不需要对单双引号进行转义）引起来的字符串。<br>转义字符：<br>    语法: \ + 字符<br>    (1)将无意义的字符变得有意义<br>    (2)将有意义的字符变得无意义<br>    例如：<br>        \n 或者 \r\n : 代表换行<br>        \t   : 代表一个tab缩进(水平制表符)<br>        \r   : 把\r后面的字符提到行首<br>        strvar = “处处\r蚊子咬”<br>        print(strvar)<br>元字符串：r+字符串：作用在于让转义字符失效，原型化输出<br>        strvar = r’夜来\n大狗熊’<br>        print(strvar)<br>        strvar = r”夜来\n大狗熊”<br>        print(strvar)<br>        strvar = r’’’夜来\n大狗熊’’’<br>        print(strvar)<br>        strvar = r”””夜来\n大狗\r熊\t”””<br>        print(strvar)<br>（3）List列表类型<br>特征：可获取，可修改de有序容器类型数据。<br>定义空列表：<br>    listvar = []<br>    print(listvar)<br>列表值的获取：<br>    listvar = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]<br>    res = listvar[1]<br>    res = listvar[len(listvar) - 1]<br>列表的修改：<br>    listvar = [‘a’, 14, 3,14, True, 4 + 3j]<br>    listvar[1] = “15”<br>（4）Tuple元组类型<br>特征：可获取，不可修改的有序的容器类型数据<br>定义空元组：<br>    tuplevar = ()<br>tuple类型的获取：<br>    tuplevar = (‘a’, ‘c’, ‘b’, ‘s’, 15 - 9j, False)<br>    res = tuplevar[-3]<br>tuple类型不支持修改</p>
<pre><code># error
tuplevar[0] = 1234
print(tuplevar)
</code></pre><p>(5)Set集合类型<br>特征：自动去重，无序的容器类型数据。<br>作用：集合类型是用来做交集、差集、并集、补集操作的。<br>注意点：<br>无法通过索引来获取其中的数据。<br>    setvar = {True, “你好”, 34, 9.2, 3 + 4j}<br>    print(setvar)<br>    print(setvar[1]) # error<br>无法修改集合当中的值<br>    setvar[0] = “999” # error<br>    print(setvar)<br>单独定义一个{} 它代表的不是集合 而是字典<br>    var = {} # 空字典<br>    print(type(var)) #dict<br>    var = set() # 空集合<br>    print(type(var))<br>(6)Dict字典类型<br>特征：键值对存储的，无序容器类型数据。<br>dictvar = {‘top’: ‘程咬金’, ‘middle’: ‘貂蝉’, ‘bottm’: ‘鲁班七号’, ‘support’: ‘蔡文姬’, ‘jungle’: ‘韩信’}<br>字典的获取：通过键获取值<br>    res = dictvar[‘jungle’]<br>    print(res)<br>字典的修改<br>    dictvar[‘middle’] = ‘小乔’<br>    print(dictvar)</p>
<p>四、类型转换<br>–&gt;自动类型转换<br>当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高:bool、int、float、complex。<br>–&gt;强制类型转换<br>Number类型强制转换<br>通过int()、float()、complex()可以将整型、浮点型、布尔型以及纯数字字符串强转为对应的类型数据，而通过bool()则可以将Number类型数据和容器类型数据强转为bool类型数据。（扩展：布尔类型为假的时候，一共有10种情况：0, 0.0, False, 0j, ‘’, [], (), {}, set(), None）<br>容器类型强制转换<br>通过str()可以将Number类型和容器类型强制转为String型。<br>通过list()可以将字符串、列表、元组、集合、字典类型强制转换为List类型，把字典强转成列表,只要其中的键,忽略其中的值。<br>通过tuple()可以将容器类型数据强转为tuple类型数据，把字典强转成列表,只要其中的键,忽略其中的值。<br>通过set()可以将容器类型数据强制转换为集合类型数据，把字典强转成集合,只要其中的键,忽略其中的值。<br>dict()<br>使用 二级列表 或 二级元组   (二级集合语法上不错,但是无序,不建议使用)<br>‘’’强转成字典的条件：需要等长的二级容器’’’</p>
<h1 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h1><p>var1 = [(“a”: 1), (“b”, 2)]<br>var2 = [[‘a’: 3], [‘b’: 4]]<br>var3 = [(‘a’: 5), [‘b’: 6]]</p>
<h1 id="var4-‘a’-7-‘b’-8"><a href="#var4-‘a’-7-‘b’-8" class="headerlink" title="var4 = [{‘a’: 7}, {‘b’: 8}]"></a>var4 = [{‘a’: 7}, {‘b’: 8}]</h1><h1 id="res-print-var4"><a href="#res-print-var4" class="headerlink" title="res = print(var4)"></a>res = print(var4)</h1><p>print(res, type(res))</p>
<h1 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h1><p>var1 = ((‘a’, 1), (‘b’, 2))<br>var2 = ([‘a’, 3], [‘b’, 4])<br>var3 = ((‘a’, 5), [‘b’, 6])</p>
<h1 id="var4-‘a’-7-‘b’-8-切记不要使用"><a href="#var4-‘a’-7-‘b’-8-切记不要使用" class="headerlink" title="var4 = [{‘a’,7},{‘b’,8}] 切记不要使用"></a>var4 = [{‘a’,7},{‘b’,8}] 切记不要使用</h1><h1 id="res-dict-var4"><a href="#res-dict-var4" class="headerlink" title="res = dict(var4)"></a>res = dict(var4)</h1><p>print(res)</p>
<h1 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h1><p>var = {(‘a’, 1), (‘b’, 2)}<br>res = dict(var)<br>print(res)</p>
<p>五、以下数据类型存储规律仅对当前linux 64位的python3.x版本负责<br>–&gt;Number 部分<br>1.对于整型而言，-5~正无穷范围内的相同值 id一致<br>2.对于浮点数而言，非负数范围内的相同值 id一致<br>3.布尔值而言,值相同情况下，id一致<br>4.复数的id标识都不相同(在 实数+虚数 这样的结构中)<br>–&gt;容器类型部分<br>5.字符串而言，字符串值相同情况下，id一致<br>6.列表，元组，字典，集合无论什么情况 id标识都不同(但空元组的id标识一样)</p>
<p>六、Python运算符<br>(1)算数运算符:  + - <em> / // % **<br>(2)比较运算符:  &gt; &lt; &gt;= &lt;= == !=<br>(3)赋值运算符:  = += -= </em>= /= //= %= **=<br>(4)成员运算符:  in 和 not in (针对于容器型数据)<br>(5)身份运算符:  is 和 is not (检测两个数据在内存当中是否是同一个值)<br>(6)逻辑运算符:  and or not<br>True and print(1)<br>False and print(2) # 逻辑与短路<br>True or print(3) # 逻辑或短路<br>False or print(4)<br>(7)位运算符:    &amp; | ~ ^ &lt;&lt; &gt;&gt;<br>按位非是对补码进行操作的，每一位按位取反，包括高位符号位(注意：原码和补码之间的互相转换，符号位不动)<br>运算规律：公式：-(x + 1)<br>例如：<br>~19<br>补码:   00000000  10011<br>按位非: 11111111  01100<br>给补码求原码:<br>取反:1111111  10011<br>加1 :1111111  10100 (原码)<br>最终: -20<br>~(-19)<br>原码：11111111   10011<br>给原码求补码：<br>取反：11111111   01100<br>加一：11111111     01101<br>按位非运算：<br>      00000000   10010<br>最终：18<br>运算符的优先级：<br>一元运算符优先级 大于 二元运算符<br>    一元运算符（~按位非  -负号）<br>    例：~19只对一个数进行操作的运算符叫做一元运算符<br>    二元运算符<br>    例：1 + 2 对两个数 进行操作的运算符叫做二元运算符<br>运算符优先级最低的是 赋值运算符当中的=<br>运算符整体的优先顺序如下：<br>    算数运算符 &gt; 位运算符 &gt; 比较运算符 &gt; 赋值运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符</p>
<p>七、流程控制<br>大致分为三种控制结构：顺序结构、分支结构、循环结构。<br>分支结构分为：单项分支、双项分支、多项分支、巢状分支，通过if elif else关键字来构建。<br>循环结构分为while / for… in…，通过循环结构可以减少代码的冗余，提高执行效率。for…in…循环多用于遍历容器类型数据，而while则不能遍历无序的容器类型数据。在遍历字典时，默认遍历字典的键。遍历等长的二级列表：<br>    listvar = [[‘a’, ‘b’, ‘c’], [‘d’, ‘e’, ‘f’], [‘g’, ‘h’, ‘j’]]<br>    for i, j, k in listvar:<br>        print(i, j, k)<br>字符串的拼接：<br>–&gt;正常拼接：通过“+”来拼接。<br>    a = ‘1’<br>    b = ‘2’<br>    print(a + b)<br>–&gt;跨行拼接：通过\来衔接不同的多行。<br>    strvar = “123456”\<br>             “7890”<br>–&gt;重复拼接：通过字符 <em> 次数。<br>    strvar = ‘love’ </em> 10</p>
<p>pass用来占位 / break终止当前循环，只能用在循环当中 / continue跳过当前循环，后面的代码不执行，直接从下一次循环开始</p>
<p>八、函数<br>关于函数<br>(1)函数的含义:功能 (包裹一部分代码 实现某一个功能 达成某一个目的)<br>(2)函数特点:可以反复调用,提高代码的复用性,提高开发效率,便于维护管理<br>(3)函数基本格式<br>    def func():<br>        pass<br>(4)驼峰命名法：（便于程序员更为方便的阅读代码）<br>大驼峰命名法：MyCar（用在类的命名中）；<br>小驼峰命名法：myCar（一般用在函数命名中）；<br>普通情况下，一般用_来分割不同的词。</p>
<pre><code># 99乘法表的定义
def multiplication99_table():
    for i in range(1, 10):;
        for j in range(1, i + 1):
            print(&quot;%d*%d=%2d &quot; % (i, j, i*j), end=&quot;&quot;)
        print()
# 99乘法表的调用
multiplication99_table()
</code></pre><p>关于函数参数<br>(1)函数参数概念及分类<br>    函数参数:调用时需要传递的数据.<br>    函数参数大类分为形参和实参:<br>        形参: 在函数定义时，括号里面的参数，叫形参（形式参数）<br>        实参: 在函数调用时，括号里面的参数，叫实参（实际参数）<br>    形参与实参的关系:函数调用时,形参和实参个数需要一一对应<br>    形参种类:普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数<br>    实参种类:普通实参,关键字实参<br>  默认形参和关键字实参区别：默认形参和关键字实参写法上一样，只不过默认形参在函数的定义处，关键字实参在函数的调用处。<br>(2)收集参数:<br>    普通收集参数:在形参当中，<em>号后面的参数是收集参数，用于专门收集多余的普通参数,形成一个新的元组。语法:参数前面加</em>    例:*args。</p>
<pre><code># 例子：计算任意个数的累加和
def my_sum(*args):
    total = 0
    for i in args:
        total += i
    print(total)
my_sum(1, 2, 3, 77, 11)
关键字收集参数:用于专门收集多余关键字实参的是关键字收集参数,形成一个新的字典。语法:参数前面加**    例:**kwargs。
# 例子：任意参数的拼接
def link_str(**kwargs):
    print(kwargs)#{&apos;monitor&apos;:&apos;zhangbojin&apos;,&apos;zhangsan&apos;:&apos;zhangsan&apos;,&apos;school_beauty&apos;:&apos;wangitechui&apos;}
    strvar1 = &apos;&apos;
    strvar2 = &apos;&apos;
    keydict = {&apos;monitor&apos;:&apos;班长&apos;,&apos;school_beauty&apos;:&apos;校花&apos;}
    for key,val in kwargs.items():
        if key in keydict:
            strvar1 += keydict[key] + val + &apos;\n&apos;
        else: 
            strvar2 += val
    print(strvar1+&quot;今天结婚,喜结良缘&quot;+&quot;,到场的吃瓜群众是&quot;+strvar2)
link_str(monitor=&quot; 张铂金 &quot;,school_beauty=&quot; 王铁锤 &quot;,zhangsan = &apos;张三&apos; )
</code></pre><p>(3)命名关键字参数:定义时放在<em>号后面的参数,调用时强制必须指定关键字实参才能调。<br>在函数定义时，写在</em>后面的参数2是命名关键字参数（假定参数3是关键字收集参数）<br>语法:(*,x) x是命名关键字参数。<br>作用：在函数调用的时候，必须使用关键字实参进行调用**保证参数3不是关键字收集参数时，那么此刻参数2，参数3都是命名关键字参数</p>
<p>(4)关于<em>和**的 实参 调用:在调用时,容器类型数据前面加</em> 或者 <strong><br>在函数的调用处：例：func2(*listvar, </strong>dictvar)</p>
<ul>
<li>用在修改容器类型的数据，把容器里面的数据，一个一个拿出来，当成参数传递给函数<br>** 用在修饰字典类型的数据，意味着把字典中的{键: 值} =&gt;变成键=值,一个个当成参数赋值给函数调用<h1 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h1>  def func(a,b,*args,c,d):<pre><code>print(a,b)
print(args)
print(c)
print(d)
</code></pre>  func(1,2,3,4,5,c=6,d=999)<h1 id="号用法"><a href="#号用法" class="headerlink" title="*号用法"></a>*号用法</h1>  print(“======”)<br>  listvar = [1, 2, 3]<br>  func1(*listvar)<h1 id="func1-listvar-等价于-func1-1-2-3"><a href="#func1-listvar-等价于-func1-1-2-3" class="headerlink" title="func1(*listvar) 等价于 func1(1, 2, 3)"></a>func1(*listvar) 等价于 func1(1, 2, 3)</h1><h1 id="号用法-1"><a href="#号用法-1" class="headerlink" title="**号用法"></a>**号用法</h1>  dictvar = {‘d’: 4}<br>  func2(1, 2, 3, **dictvar)<h1 id="func2-1-2-3-dictvar-等价于-func2-1-2-3-d-4"><a href="#func2-1-2-3-dictvar-等价于-func2-1-2-3-d-4" class="headerlink" title="func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)"></a>func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)</h1><h1 id="函数的调用处"><a href="#函数的调用处" class="headerlink" title="函数的调用处"></a>函数的调用处</h1>  func2(<em>listvar,**dictvar)<br>(5)形参声明的位置顺序:<br>  普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt; 命名关键字参数 -&gt; 关键字收集参数<br>(6)对于任意函数，都可以通过 def func(</em>args, **kw) 来获取所有参数<h1 id="参数练习："><a href="#参数练习：" class="headerlink" title="参数练习："></a>参数练习：</h1>def f1(a, b, c=0, <em>args, **kwargs):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)<br>def f2(a, b, c=0, </em>, d, *kw):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘d =’, d, ‘kw =’, kw)<h1 id="以上两个函数-打印结果"><a href="#以上两个函数-打印结果" class="headerlink" title="以上两个函数 打印结果"></a>以上两个函数 打印结果</h1>#(一)<br>f1(1, 2) #a = 1 b = 2 c = 0 args = () kw = {}<br>f1(1, 2, c=3) #a = 1 b = 2 c = 3 args = () kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’, x=99) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99}<br>f2(1, 2, d=99, ext=None) #a = 1 b = 2 c = 0 d = 99 kw = {‘ext’: None}<br>#(二)<br>args = (1, 2, 3, 4)<br>kw = {‘d’: 99, ‘x’: ‘#’}<br>f1(*args, **kw)  #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}<h1 id="f1-1-2-3-4-d-99-x-’-’"><a href="#f1-1-2-3-4-d-99-x-’-’" class="headerlink" title="f1(1,2,3,4,d=99,x=’#’)"></a>f1(1,2,3,4,d=99,x=’#’)</h1>#(三)<br>myargs = (1, 2, 3)<br>mykw = {‘d’: 88, ‘x’: ‘#’}<br>f2(*myargs, **mykw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}<h1 id="f2-1-2-3-d-88-x-’-’"><a href="#f2-1-2-3-d-88-x-’-’" class="headerlink" title="f2(1,2,3,d=88,x=’#’)"></a>f2(1,2,3,d=88,x=’#’)</h1>#(四)<br>def f1(a, b, c=0, *args,d,**kw):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)<br>  print(d)<br>f1(1,2,3, ‘a’, ‘b’,d=67, x=99,y=77) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99, ‘y’: 77}</li>
</ul>
<p>return返回值<br>为这个函数返回一个结果 (return返回值可有可无 按照需求选择)注意:执行return语句之后,函数执行结束</p>
<p><strong><strong>doc</strong></strong>：<strong>doc</strong>或者help查看文档</p>
<p>全局变量、局部变量及其关键字的使用<br>– global   关键字:声明全局变量,作用在于修改全局变量<br>– nonlocal 关键字:声明函数内部的局部变量,作用在于修改局部变量(当前函数上一层的局部变量)</p>
<p>内部函数<br>(1)内部函数可以直接在函数外部调用么<br>(2)调用外部函数后,内部函数可以在函数外部调用吗<br>(3)内部函数可以在函数内部调用吗<br>(4)内部函数在函数内部调用时,是否有先后顺序</p>
<p>闭包<br>闭包的定义:<br>内函数使用外函数的局部变量，并且外函数将内函数返回出来的方法叫闭包,返回的内函数叫闭包函数。<br>闭包的特点:<br>外函数的临时变量会在将来的内部函数中用到,自己调用结束后会把外函数的临时变量与内函数绑定,不释放将来调用内函数的时候仍可使用外函数变量。<br>闭包的意义:<br>闭包可以优先使用外函数中的变量,并对闭包中的值起到了封装保护的作用.外部无法访问。</p>
<p>递归函数<br>递归的定义：自己调用自己就是递归函数。<br>递归的注意事项：<br>函数调用的过程就是开辟栈帧和释放栈帧的过程，调用结束时开辟栈帧空间，结束时释放（话外之意是不结束这层栈帧不释放）。<br>递归每次调用都会开辟一个栈帧，如果递归的层数过多，不建议使用，容易内存溢出。<br>每次开辟的栈帧空间，代码必须全部执行完毕之后才释放空间，在回到上一个栈帧执行没结束的代码。<br>如果使用递归，需要给予一个跳出的条件，不能无限递归。</p>
<p>匿名函数<br>实际上就是通过lambda表达式来书写的。一般只用来实现一些简单的函数功能，写法非常方便。</p>
<p>迭代器：<br>定义：能被next()函数调用并且不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）。<br>特征：迭代器会生成惰性序列，它通过计算把值依次地返回，一边循环一边计算而不是一次性得到所有数据。<br>优点：需要数据的时候，一次取一个，可以大大节省内存空间，而不是一股脑地把所有数据放进内存。‘<br>惰性序列：没有一次性的把所有数据都放在序列中，而是遍历一个放一个，这样的序列叫做惰性序列。<br>Iterable可迭代性    Iterator迭代器<br>range是可迭代对象<br>range和迭代器能够产生惰性序列</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-14T10:42:29.000Z"><a href="/2018/10/14/Python OS模块常用方法总结/">2018-10-14</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/14/Python OS模块常用方法总结/">Python OS模块常用方法总结</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><p>操作               说明</p>
</li>
<li><p>os.getcwd()    得到当前工作目录，即当前Python脚本工作的目录路径</p>
</li>
<li>os.listdir()    返回指定目录下的所有文件和目录名</li>
<li>os.remove()    函数用来删除一个文件</li>
<li>os.removedirs(r”c\python”)    删除多个目录</li>
<li>os.path.isfile()    检验给出的路径是否是一个文件</li>
<li>os.path.isdir()    检验给出的路径是否是一个目录</li>
<li>os.path.isabs()    判断是否是绝对路径</li>
<li>os.path.exists()    检验给出的路径是否真地存</li>
<li>os.path.split()    返回一个路径的目录名和文件名</li>
<li>os.path.splitext()    分离扩展名</li>
<li>os.path.dirname()    获取路径名</li>
<li>os.path.basename()    获取文件名</li>
<li>os.system()    运行shell命令</li>
<li>os.getenv()与os.putenv()    读取和设置环境变量</li>
<li>os.linesep     给出当前平台使用的行终止符，Windows使用’rn’，Linux使用’n’而Mac使用’r’</li>
<li>os.name    指示你正在使用的平台，对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’</li>
<li>os.rename(old, new)    重命名：</li>
<li>os.makedirs(r”c：\python\test”)    创建多级目录</li>
<li>os.mkdir(“test”)    创建单个目录</li>
<li>os.stat(file)    获取文件属性</li>
<li>os.chmod(file)    修改文件权限与时间戳</li>
<li>os.exit()    终止当前进程</li>
<li>os.path.getsize(filename)    获取文件大小</li>
<li>os.mkdir(“file”)    创建目录</li>
<li>os.rename(“oldname”,”newname”)    重命名文件（目录）,文件或目录都是使用这条命令</li>
<li>os.remove(“file”)    删除文件</li>
<li>os.rmdir(“dir”)    删除目录, 只能删除空目录</li>
<li>os.chdir(“path”)    转换目录, 换路径</li>
<li>os.mknod(“test.txt”)    创建空文件</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-14T03:32:35.000Z"><a href="/2018/10/14/HTML5CSS3_001/">2018-10-14</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/14/HTML5CSS3_001/">HTML5/CSS3新特性、移除的元素及兼容问题</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有："><a href="#HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：" class="headerlink" title="HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有："></a>HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：</h3><ul>
<li>绘画canvas元素</li>
<li>用于媒介回放的 video 和 audio 元素</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
<li>表单控件，calendar、date、time、email、url、search<h3 id="CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。"><a href="#CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。" class="headerlink" title="CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。"></a>CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。</h3><h3 id="移除的元素包括："><a href="#移除的元素包括：" class="headerlink" title="移除的元素包括："></a>移除的元素包括：</h3></li>
<li>纯表现的元素  basefont、big、center、font、 s、strike、tt、u；</li>
<li>对可用性产生负面影响的元素  frame、frameset、noframes。<h3 id="浏览器兼容问题解决方案："><a href="#浏览器兼容问题解决方案：" class="headerlink" title="浏览器兼容问题解决方案："></a>浏览器兼容问题解决方案：</h3>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式，当然最好的方式是直接使用成熟的框架：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt; </span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; </span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:sirxy.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/HTML5-CSS3/">HTML5/CSS3</a><small>1</small></li>
  
    <li><a href="/tags/HTTP学习/">HTTP学习</a><small>1</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>1</small></li>
  
    <li><a href="/tags/Nginx学习/">Nginx学习</a><small>3</small></li>
  
    <li><a href="/tags/Python基础/">Python基础</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 John Doe
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
