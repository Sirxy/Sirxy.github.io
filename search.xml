<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Virtualenv虚拟环境]]></title>
    <url>%2F2019%2F04%2F11%2FVirtualenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[VirtualenvVirtualEnv用于在一台机器上创建多个独立的Python虚拟运行环境，多个Python环境相互独立，互不影响，它能够：在没有权限的情况下安装新套件；不同应用可以使用不同的套件版本；套件升级不影响其他应用。 ubuntu16.04安装: 1$ [sudo] pip3 install virtualenv 创建虚拟环境 1$ virtualenv venv 激活虚拟环境 12345678910ubuntu: $ source venv/bin/activatewindows: cd ./f1/Scripts/ activate.bat (f1) F:\tulingxueyuan\f1\Scripts&gt;``` 当虚拟环境被激活了，Python解释器的位置会被添加到PATH中，但是这个改动并不是永久的；它只影响当前命令会话。提醒一下，你激活了虚拟环境，该激活命令会将环境的名称包含在命令提示符里面： (venv) $12- 停止虚拟环境当你在虚拟环境中完成工作并想回到全局Python解释器，在命令提示符中输入deactivate就可以了。 $ deactivate1234567### 使用pip安装python包大多数的Python包是通过pip程序安装的，在创建虚拟环境的时候virtualenv会自动添加进去。当一个虚拟环境被激活后，pip程序的位置会被添加到PATH中。注：如果你使用pyvenv创建虚拟环境在Python 3.3中，则必须手动安装pip。安装指令在pip网站上可以找到。在Python 3.4下，pyvenv会自动安装pip。比如，安装Flask到虚拟环境中，使用下面的命令： (venv)$ pip install flask1通过这个命令，Flask和它的依赖集都会安装到虚拟环境中。你可以验证Flask是否正确安装通过启动Python解释器并试着导入它： (venv)$ python import flask 1如果需要安装的包比较多的时候，这样做会比较繁琐，我们还有一键安装的方法。首先新建一个文本文件，如：requirements.txt，然后将你需要安装的包名保存到该文件中(根据自己的需要)，如下： Babel==1.3Flask==0.10.1Flask-Login==0.2.7Flask-SQLAlchemy==1.0Flask-WTF==0.9.3Jinja2==2.7.1SQLAlchemy==0.8.2WTForms==1.0.5Werkzeug==0.9.4psycopg2==2.5.1…1最后你只需要输入以下命令，所有需要的包就可以全部安装好了： (venv)$ pip install -r requirements.txt123如果没有出现错误，祝贺你：安装成功了。若要查看当前环境安装了哪些包，可以使用下面的命令： (venv)$ pip freeze1还可以直接导出到文件中 (venv)$ pip freeze &gt; requirements.txt123### 移除环境删除虚拟环境只需通过停用虚拟环境并删除环境文件夹及其所有内容即可完成： (ENV)$ deactivate$ rm -r /path/to/ENV` 持续中。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你三分钟学会Ajax]]></title>
    <url>%2F2019%2F04%2F11%2Fajax%2F</url>
    <content type="text"><![CDATA[ajax是什么?AJAX 指异步 JavaScript 及 XML（Asynchronous JavaScript And XML）。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。AJAX 是一种在 2005 年由 Google 推广开来的编程模式。AJAX 不是一种新的编程语言，而是一种使用现有标准的新方法。通过 AJAX，你可以创建更好、更快以及更友好的 WEB 应用程序。AJAX 基于 JavaScript 和 HTTP 请求（HTTP requests）。通过 HTTP 请求加载远程数据。 jQuery 底层对 AJAX 实现进行了封装.使得我们在进行ajax操作时,不必像原生js中那么复杂$.get, $.post, $.ajax() 返回其创建的 XMLHttpRequest 对象。多数情况下我们不需要去操作返回的对象 如何使用ajax技术?首先你得有web服务器,能够通过浏览器去执行你的html和你的python，注意一点:我们平常写的html,直接在浏览器打开时 使用的是file协议，而ajax是基于HTTP请求的,所以要求你的html能够使用http的协议打开如果你能做到用http协议去打开你的html并且能够正常显示的话,就代表你的web服务器搭建成功。 $.get() 方法: 12//发送ajax请求 1.url 2.可选 发送get请求时携带的参数 ,3,可选 回调函数,请求完之后做什么事 4,可选,返回的数据类型 json$.get(url,&#123;请求的参数&#125;,function(data)&#123;&#125;,&apos;json&apos;) $.post() 1$.post(url,&#123;请求的参数&#125;,function(data)&#123;&#125;,&apos;json&apos;) $.ajax() 12345678910111213141516$.ajax(&#123; url:&apos;/cgi-bin/5.py&apos;,//当前请求的url地址 type:&apos;get&apos;,//当前请求的方式 get post data:&#123;id:100,username:&apos;zhangsan&apos;&#125;,//请求时发送的参数 dataType:&apos;json&apos;,//返回的数据类型 success:function(data)&#123; //ajax请求成功后执行的代码 console.log(data); &#125;, error:function()&#123; //ajax执行失败后执行的代码 alert(&apos;ajax执行错误&apos;); &#125;, timeout:2000,//设置当前请求的超时时间 毫秒,必须时异步请求才会生效 async:true// 是否异步 true为异步 false 同步&#125;) ajax异步 同步 1234//设置ajax的全局配置 async:false 设置当前请求为同步$.ajaxSetup(&#123; async:false&#125;) 关于ajax中 异步 和 同步：ajax默认就是异步请求,async (默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。同步请求,就发ajax请求发出去后必须等待ajax的结果返回后才能继续往下执行。一般情况下都使用异步操作就可以,除非有特殊情况,必须等ajax的结果回来后才能做处理的,就用同步。 扩展：了解json格式数据json是 JavaScript Object Notation 的首字母缩写，单词的意思是javascript对象表示法，这里说的json指的是类似于javascript对象的一种数据格式，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。 javascript对象字面量：1234var tom = &#123; name:&apos;tom&apos;, age:18&#125; json格式的数据：1234&#123; &quot;name&quot;:&apos;tom&apos;, &quot;age&quot;:18&#125; 与json对象不同的是，json数据格式的属性名称需要用双引号引起来，用单引号或者不用引号会导致读取数据错误。 json的另外一个数据格式是数组，和javascript中的数组字面量相同。1[&apos;tom&apos;,18,&apos;programmer&apos;] 持续中。。。。。。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB简介与安装]]></title>
    <url>%2F2019%2F04%2F11%2FMongoDB%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是MongoDB ?MongoDB 是一个基于分布式文件存储的开源数据库系统。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 主要特点1.MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。2.你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。3.你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。4.如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。5.Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。6.MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。7.Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。8.Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。9.Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。10.GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。11.MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。12.MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。MongoDB安装简单。 ubuntu16.04通过apt-get方式安装MongoDB虽然Ubuntu本身也提供MongoDB安装包，但往往官网的安装包版本更新。12345678910~$ apt-cache show mongodb-clientsPackage: mongodb-clientsPriority: optionalSection: universe/databaseInstalled-Size: 160066Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;Original-Maintainer: Laszlo Boszormenyi (GCS) &lt;gcs@debian.org&gt;Architecture: amd64Source: mongodbVersion: 1:2.6.10-0ubuntu1 # 版本号 安装: 1.导入包管理系统使用的公钥1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 2.为MongoDB创建一个列表文件 根据版本创建/etc/apt/sources.list.d/mongodb-org-3.4.list 列表文件Ubuntu 16.041echo &quot;deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list 3.更新本地包数据库1sudo apt-get update 4.安装最新版本的MongoDB1sudo apt-get install -y mongodb-org 5.查看配置文件 配置文件mongod.conf所在路径:/etc/mongod.conf内容:123456789101112131415161718192021222324252627282930313233343536373839404142# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb #数据库存储路径 journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true #以追加的方式写入日志 path: /var/log/mongodb/mongod.log #日志文件路径# network interfacesnet: port: 27017 bindIp: 127.0.0.1 #绑定监听的ip 127.0.0.1只能监听本地的连接，可以改为0.0.0.0#processManagement:#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: 6.启动和关闭MongoDB123456sudo service mongod start # 启动sudo service mongod stop # 关闭hupeng@hupeng-vm:~$ ps aux | grep mongod # 查看守护进程mongod的运行状态mongodb 18454 9.5 1.5 292152 61952 ? Ssl 12:27 0:00 /usr/bin/mongod --quiet --config /etc/mongod.confhupeng 18475 0.0 0.0 15964 936 pts/4 R+ 12:27 0:00 grep --color=auto mongod 卸载1.关闭守护进程mongod1sudo service mongod stop 2.卸载安装的软件包1sudo apt-get purge mongodb-org* 3.移除数据库和日志文件（数据库和日志文件的路径取决于/etc/mongod.conf文件中的配置)1234sudo rm -r /var/log/mongodbsudo rm -r /var/lib/mongodb 参考文档: Install MongoDB Community Edition on Ubuntu —— MongoDB Manual]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作redis]]></title>
    <url>%2F2019%2F04%2F11%2FPython%E6%93%8D%E4%BD%9Credis%2F</url>
    <content type="text"><![CDATA[Python 访问 Redis对于使用 Python 访问 Redis，我们需要先安装 redis-py 软件包，该包实现了 Python 的 Redis 驱动。通过以下命令建立工作环境，安装软件包：1$ sudo pip3 install redis Python 操作 RedisPython 中访问 Redis 可以通过redis-py软件包进行。类似于 PyMongo, 也是需要先创建一个 Redis 客户端，如下代码基本操作:1234import redisr = redis.Redis(host=&apos;127.0.0.1&apos;, port=6379,decode_responses=True)r.set(&apos;name&apos;, &apos;OK&apos;)print(r.get(&apos;name&apos;))]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis高级实用特性]]></title>
    <url>%2F2019%2F04%2F11%2FRedis%E9%AB%98%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Redis 安全我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。查看是否设置了密码验证：123127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot; 默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。 临时修改密码(redis服务重启后不再生效)12345127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;runoob&quot; 配置文件为Redis添加密码12345678910111213141516171819202122修改配置文件sudo vim /etc/redis/redis.conf设置：requirepass redis的密码# requirepass foobaredrequirepass abc123重启服务sudo service redis restart登录（两种）1.# ./redis-cli -a 密码 //连接时指定密码来进行授权2.redis-cli 进入后发现操作不了时 auth 密码 OK---------------------windows 下设置密码生效修改配置文件启动服务 加载配置文件redis-server redis.conf \(加载一次即可\)启动客户端 Redis主从复制操作步骤：1234567891011121314151617181920211.先将linux虚拟机关闭，之后克隆一个。2.启动两个虚拟机：master（主）和slave（从）3. 在slave（从）中配置一下ip地址 \# ifconfig eth0 192.168.128.229 \# ping 一下看看通不通。4. 配置从机 进入：配置文件 slaveof 192.168.128.228 6379 //配置连接主机的Redis的ip和端口 masterauth 密码 //配置连接密码 最后启动slave（从）机的Redis服务。其他：可以通过info命令中的role属性查看自己角色是master、slave Redis事务12345&gt;multi //开启一个事务&gt;set age 10 //暂存指令队列&gt;set age 20&gt;exec //开始执行（提交事务）或&gt;discard //清空指令队列（事务回滚） Redis乐观锁12345678Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断在事务前对被操作的属性做一个：&gt; watch age&gt;multi //开启一个事务(在此期间有其他修改，则此处会失败)&gt;set age 10 //暂存指令队列&gt;set age 20&gt;exec //开始执行（提交事务）或&gt;discard //清空指令队列（事务回滚） Redis持久化机制(通过修改配置文件做设置)12345678910111213141.snapshotting(快照)默认方式 配置 save save 900 1 #900秒内如果超过1个key被修改，则发起快照保存 save 300 10 #300秒内容如超过10个key被修改，则发起快照保存 save 60 100002.Append-only file（aof方式） 配置 appendonly on 改为yes 会在bin目录下产生一个.aof的文件 关于aof的配置 appendonly yes //启用aof 持久化方式 # appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化 appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中 # appendfsync no //完全依赖os，性能最好,持久化没保证 Redis发布订阅Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 123456789101112131415161718192021222324252627282930313233我们创建了订阅频道名为 redisChat:redis 127.0.0.1:6379&gt; SUBSCRIBE redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by runoob.com&quot;(integer) 1# 订阅者的客户端会显示如下消息1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;Redis is a great caching technique&quot;1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;Learn redis by runoob.com&quot;----------------------------序号 命令及描述1 PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。2 PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。3 PUBLISH channel message 将信息发送到指定的频道。4 PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。5 SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。6 UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。 Redis配置虚拟内存和大多NoSQL数据库一样，Redis同样遵循了Key/Value数据存储模型。在有些情况下，Redis会将Keys/Values保存在内存中以提高数据查询和数据修改的效率，然而这样的做法并非总是很好的选择。鉴于此，我们可以将之进一步优化，即尽量在内存中只保留Keys的数据，这样可以保证数据检索的效率，而Values数据在很少使用的时候则可以被换出到磁盘。 在实际的应用中，大约只有10%的Keys属于相对比较常用的键，这样Redis就可以通过虚存将其余不常用的Keys和Values换出到磁盘上，而一旦这些被换出的Keys或Values需要被读取时，Redis则将其再次读回到主内存中。1234567在redis配置文件中设置vm-enabled yes #开启vm功能vm-swap-file /tmp/redis.swap #交换出来的value保存的文件路径vm-max-memory 1000000 #redis使用的最大内存上限vm-page-size 32 #每个页面的大小32字节vm-pages 134217728 #最多使用多少页面vm-max-threads 4 #用于执行value对象换入患处的工作线程数量 持续中。。。。。。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库之数据类型]]></title>
    <url>%2F2019%2F04%2F11%2FRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Redis的数据类型Redis通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。下面介绍redis数据类型： String（子串类型） 123456789101112131415161718192021222324252627282930313233343536373839404142434445set 命令：设置一个键和值，键存在则只覆盖，返回ok&gt; set 键 值 例如： &gt;set name zhangsanget 命令：获取一个键的值，返回值&gt; get 键 例如：&gt;get namesetnx命令：设置一个不存在的键和值（防止覆盖），&gt; setnx 键 值 若键已存在则返回0表示失败setex命令：设置一个指定有效期的键和值（单位秒）&gt; setex 键 [有效时间] 值 例如: &gt;setex color 10 red 不写有效时间则表示永久有效，等价于setsetrange命令：替换子字符串 (替换长度由子子串长度决定)&gt; setrange 键 位置 子字串&gt; setrange name 4 aa 将name键对应值的第4个位置开始替换mset命令：批量设置键和值,成功则返回ok&gt; mset 键1 值1 键2 值2 键3 值3 ....msetnx命令：批量设置不存在的键和值,成功则返回ok&gt; msetnx 键1 值1 键2 值2 键3 值3 ....getset命令：获取原值，并设置新值getrange命令：获取指定范围的值&gt;getrange 键 0 4 //获取指定0到4位置上的值mget命令： 批量获取值&gt;mget 键1 键2 键3....incr命令： 指定键的值做加加操作，返回加后的结果。&gt; 键 例如： &gt;incr kidincrby命令： 设置某个键加上指定值&gt; incrby 键 m //其中m可以是正整数或负整数decr命令： 指定键的值做减减操作，返回减后的结果。&gt; decr 键 例如： &gt;decr kiddecrby命令： 设置某个键减上指定值&gt; decrby 键 m //其中m可以是正整数或负整数append命令：给指定key的字符串追加value，返回新字符串值的长度&gt;append 键 追加字串strlen求长度 &gt;strlen 键名 //返回对应的值。 Hash类型Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 123456789101112131415161718192021hset命令：设置一个哈希表的键和值&gt;hset hash名 键 值如：&gt;hset user:001 name zhangsanhget命令： 获取执行哈希名中的键对应值hsetnx命令：设置一个哈希表中不存在的键和值&gt;hsetnx hash名 键 值 //成功返回1，失败返回0如：&gt;hsetnx user:001 name zhangsanhmset命令:hmset user:001 username zhangsan age 20 sex 1 批量设置hmget user:001 username age sex:批量获取值&gt;hexists user:001 name //是否存在， 若存在返回1&gt;hlen user:001 //获取某哈希user001名中键的数量&gt;hdel user:001 name //删除哈希user:001 中name键&gt;hkeys user:002 //返回哈希名为user:002中的所有键。&gt;hvals user:002 //返回哈希名为user:002中的所有值。&gt;hgetall user:002 //返回哈希名为user:002中的所有键和值。 List列表（双向链表结构）Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 123456789101112131415161718192021222324252627282930list即可以作为“栈”也可以作为&quot;队列&quot;。操作：&gt;lpush list1 &quot;world&quot; //在list1头部压入一个字串&gt;lpush list1 &quot;hello&quot; // 在list1头部压入一个字串&gt;lrange list1 0 -1 //获取list1中内容 0:表示开头 -1表示结尾。&gt;rpush list2 &quot;world&quot; //在list2尾部压入一个字串&gt;rpush list2 &quot;hello&quot; // 在list2尾部压入一个字串&gt;lrange list2 0 -1 //获取list2中内容 0:表示开头 -1表示结尾。&gt;linsert list2 before hello there在key对应list的特定位置前或后添加字符串&gt;lset list2 1 &quot;four&quot;修改指定索引位置上的值&gt;lrem list2 2 &quot;hello&quot; //删除前两个hello值&gt;lrem list2 -2 &quot;hello&quot; //删除后两个hello值&gt;lrem list2 0 &quot;hello&quot; //删除所有hello值&gt;ltrim mylist8 1 3 //删除此范围外的值&gt;lpop list2 //从list2的头部删除元素，并返回删除元素&gt;rpop list2 //从list2的尾部删除元素，并返回删除元素&gt;rpoplpush list1 list2 //将list1的尾部一个元素移出到list2头部。并返回&gt;lindex list2 1 //返回list2中索引位置上的元素&gt;llen list2 //返回list2上长度 Redis 集合(Set)Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 123456789101112131415161718192021222324&gt;sadd myset &quot;hello&quot; //向myset中添加一个元素 成功返回1，失败(重复)返回0&gt;smembers myset //获取myset中的所有元素(结果是无序的)&gt;srem myset &quot;one&quot; //从myset中删除一个one 成功返回1，失败(不存在)返回0&gt;spop myset //随机返回并删除myset中的一个元素&gt;srandmember myset //随机获取myset中的一个元素，但是不删除&gt; smove myset1 myset2 zhangsan:将myset1中zhangsan移动到myset2中&gt; scard myset1 返回myset1的个数&gt; sismember myset zhangsan:判断张三是否在myset中&gt;sdiff myset1 myset2 //返回两个集合的差集以myset1为标准，获取myset2中不存在的。&gt;sdiffstore dstset myset1 myset2 ...// 返回所有集合的差集，并保存到dstset中&gt;sinter myset1 myset2 myset3... // 返回N个集合中的交集&gt;sinterstore dstset myset1 myset2 ... // 返回N个集合的交集并存储到dstset中&gt; sunion myset1 myset2 ...//返回所有集合的并集&gt; sunionstore dstset myset1 myset2// 返回所有集合的并集，并存储到dstset中 Redis 有序集合Sset (sorted set)Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。 1234567891011121314151617&gt; zadd zset 1 one 向zset中添加one，排序为1排序&gt; zrem zset one:删除zset中one&gt; zincrby zset 2 one:如果one存在，则顺序增加2，如果one不存在，那么就是2&gt; zrank zset one:返回one在zset中排名(从小到大的排序)&gt; zrevrank zset one:返回one在zset中排名(从大到小的排序)&gt; zrange zset 0 -1 withscores:根据score排序（根据score从小到大排序）&gt; zrevrange zset 0 -1 withscores:根据score排序（根据score从大到小排序）&gt; zrangebyscore zset 2 3 withscores:返回集合中score在给定区间的元素（包含2和5）&gt; zcount zset 2 3:返回集合中给定区间的数量&gt; zcard zset:返回集合中元素的个数&gt; zscore zset one:返回one元素的score&gt; zremrangebyrank zset 3 3:删除集合中排名在给定区间的元素&gt; zremrangebyscore zset 1 2:将zset中从小到大排序结果的score在1-2之间的删除 持续中。。。。。。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 数据库]]></title>
    <url>%2F2019%2F04%2F11%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis简介与安装1、Redis简介：Redis 一个内存数据库，通过 Key-Value 键值对的的方式存储数据。由于 Redis 的数据都存储在内存中，所以访问速度非常快，因此 Redis 大量用于缓存系统，存储热点数据，可以极大的提高网站的响应速度。 2、优点：支持数据的持久化，通过配置可以将内存中的数据保存在磁盘中，Redis 重启以后再将数据加载到内存中；支持列表，哈希，有序集合等数据结构，极大的扩展了 Redis 用途；原子操作，Redis 的所有操作都是原子性的，这使得基于 Redis 实现分布式锁非常简单；支持发布/订阅功能，数据过期功能；环境准备：http://www.runoob.com/redis/redis-install.html3、Ubuntu下安装在 Ubuntu 系统安装 Redi 可以使用以下命令:12$sudo apt-get update$sudo apt-get install redis-server 启动 Redis1$ redis-server 查看 redis 是否启动？1$ redis-cli 以上命令将打开以下终端：12345redis 127.0.0.1:6379&gt;127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。redis 127.0.0.1:6379&gt; pingPONG 以上说明我们已经成功安装了redis。 Redis基本操作与配置1、基本操作Redis 是 Key-Value 内存数据库，操作是通过各种指令进行的，比如 SET 指令可以设置键值对，而 GET 指令则获取某一个键的值。不同的数据结构，Redis 有不同的指令，这样指令一共有几十个，下面主要介绍一些常用的指令。Redis 对 Key 也就是键有各种各样的指令，主要有下面的指令（下面的指令中小写字符串都是参数，可以自定义）：1234567891011&gt;keys * //返回键（key）&gt;keys list* //返回名以list开头的所有键（key）&gt;exists list1 //判断键名为list1的是否存在 存在返回1， 不存在返回0&gt;del list1 //删除一个键（名为list1）&gt;expire list1 10 //设置键名为list1的过期时间为10秒后&gt;ttl list1 //查看键名为list1的过期时间，若为-1表示以过期 或 永不过期&gt;move age 1 //将键名age的转移到1数据库中。&gt;select 1 //表示进入到1数据库中，默认在0数据库&gt;persist age //移除age的过期时间&gt;flushdb:删除所有的数据 清除当前所在库的所有数据&gt;flushall 清空所有数据 2、Redis 配置Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。你可以通过CONFIG命令查看或设置配置项。123456redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAMEredis 127.0.0.1:6379&gt; CONFIG GET loglevel1) &quot;loglevel&quot;2) &quot;notice&quot; 3、Redis 配置参数说明redis.conf 配置项说明如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283841. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口， 因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794. 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项， 但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数， 如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时， Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key， 当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。 Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启， 可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的， 所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上， 访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享， vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes； 如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。 默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf 持续中。。。。。。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单线程和多线程执行对比]]></title>
    <url>%2F2019%2F04%2F10%2FThread-comparison%2F</url>
    <content type="text"><![CDATA[为了将单线程和多线程执行进行对比，下面的脚本比较了递归求斐波那契、阶乘以及累加函数的操作。该脚本按照单线程的方式运行这三个函数，接着使用多线程的方式执行同样的三个函数，以此来说明多线程环境的优点。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from myThread import MyThreadfrom time import ctime, sleepdef fib(x): sleep(0.005) if x &lt; 2: return 1 return (fib(x - 2) + fib(x - 1))def fac(x): sleep(0.1) if x &lt; 2: return 1 return (x * fac(x - 1))def sum(x): sleep(0.1) if x &lt; 2: return 1 return (x + sum(x - 1))funcs = [fib, fac, sum]n = 12def main(): nfuncs = range(len(funcs)) print(&apos;***single thread&apos;) for i in nfuncs: print(&apos;starting&apos;, funcs[i].__name__, &apos;at:&apos;, ctime()) print(funcs[i](n)) # 调用函数 print(funcs[i].__name__, &apos;finished at:&apos;, ctime()) print(&apos;***multiple threads&apos;) threads = [] for i in nfuncs: t = MyThread(funcs[i], (n, ), funcs[i].__name__) threads.append(t) for i in nfuncs: threads[i].start() for i in nfuncs: threads[i].join() print(threads[i].getResult()) print(&apos;all Done&apos;)if __name__ == &apos;__main__&apos;: main() 运行上述代码，结果如下：123456789101112131415161718192021***single threadstarting fib at: Wed Apr 10 18:23:13 2019233fib finished at: Wed Apr 10 18:23:15 2019starting fac at: Wed Apr 10 18:23:15 2019479001600fac finished at: Wed Apr 10 18:23:16 2019starting sum at: Wed Apr 10 18:23:16 201978sum finished at: Wed Apr 10 18:23:18 2019***multiple threadsstarting fib at: Wed Apr 10 18:23:18 2019starting fac at: Wed Apr 10 18:23:18 2019starting sum at: Wed Apr 10 18:23:18 2019fac finished at: Wed Apr 10 18:23:19 2019sum finished at: Wed Apr 10 18:23:19 2019fib finished at: Wed Apr 10 18:23:20 201923347900160078all Done 通过上面可以看出，以单线程模式运行只是简单地调用每个函数，并在函数执行结束后立即显示相应的结果。而以多线程模式运行时，并不会立即显示结果。因为希望让MyThread类越通用越好（即有输出和没有输出的调用都能够执行），我们要一直等到所有线程都执行结束，然后调用getResult()方法来最终显示每个函数的返回值。因为这些函数执行起来都非常快（斐波那契除外），所以你看到每个函数中都加入了sleep()用于减慢执行速度，以便让我们看到多线程是如何改善性能的。 待续中。。。。。。]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Python线程与进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程编程——threading模块]]></title>
    <url>%2F2019%2F04%2F09%2Fthreading%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[threading模块的Thread类threading模块的Thread类是主要的执行对象。它有thread模块中没有的许多函数。使用Thread类可以有很多方法来创建线程。这里介绍其中比较相似的三种方法。 方法一：创建Thread的实例，传给它一个函数。如下啊：1234567891011121314151617181920212223242526272829import threadingfrom time import sleep, ctimeloops = [4, 2]def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，打印结果如下：1234567starting at: Wed Apr 10 16:28:53 2019start loop 0 at: Wed Apr 10 16:28:53 2019start loop 1 at: Wed Apr 10 16:28:53 2019loop 1 done at: Wed Apr 10 16:28:55 2019loop 0 done at: Wed Apr 10 16:28:57 2019all done at: Wed Apr 10 16:28:57 2019[Finished in 4.2s] 方法二：创建Thread的实例，传给它一个可调用的类实例在创建线程时，与传入函数相似的一个方法是传入一个可调用的类的实例，用于线程执行——这种方法更加接近面向对象的多线程编程。这种可调用的类包含一个执行环境，比起一个函数或者从一组函数中选择而言，有更好的灵活性。现在你有了一个类对象，而不仅仅是单个函数或者一个函数列表/元组。在方法一的代码中添加一个新类ThreadFunc，并进行一些其他的轻微改动，得到下面的代码：123456789101112131415161718192021222324252627282930313233343536373839import threadingfrom time import sleep, ctimeloops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=&apos;&apos;): self.name = name self.func = func self.args = args def __call__(self): self.func(*self.args)def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # create all threads t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__)) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，得到了如下的输出：1234567starting at: Wed Apr 10 16:51:55 2019start loop 0 at: Wed Apr 10 16:51:55 2019start loop 1 at: Wed Apr 10 16:51:55 2019loop 1 done at: Wed Apr 10 16:51:57 2019loop 0 done at: Wed Apr 10 16:51:59 2019all done at: Wed Apr 10 16:51:59 2019[Finished in 4.2s] 方法三：派生Thread的子类，并创建子类的实例这种方法要介绍的这个例子要调用Thread()的子类（实际上就是继承Thread类鞭编写我们自己需要的线程类），和上一个创建可调用类的例子有些类似。当创建线程时使用子类要相对更容易阅读。 12345678910111213141516171819202122232425262728293031323334353637383940import threadingfrom time import sleep, ctimeloops = [4, 2]class MyThread(threading.Thread): # 继承 def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) # 必须调用基类的构造函数 self.name = name self.func = func self.args = args def run(self): self.func(*self.args)def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # create all threads t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all Done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，得到了如下的输出：1234567starting at: Wed Apr 10 17:07:01 2019start loop 0 at: Wed Apr 10 17:07:01 2019start loop 1 at: Wed Apr 10 17:07:01 2019loop 1 done at: Wed Apr 10 17:07:03 2019loop 0 done at: Wed Apr 10 17:07:05 2019all Done at: Wed Apr 10 17:07:05 2019[Finished in 4.2s] 本例中将对Thread子类化，而不是直接对齐实例化。这将使我们在定制线程对象时拥有更多的灵活性，也能够简化线程创建的调用过程。 现在对MyThread类进行修改，增加一些调试信息的输出，并将其存储为一个名为myThread的独立模块，以便于后面自己用到这个类。myThread.py：123456789101112131415161718import threadingfrom time import sleep, ctimeclass MyThread(threading.Thread): def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) # 必须调用基类的构造函数 self.name = name self.func = func self.args = args def getResult(self): return self.res def run(self): print(&apos;starting&apos;, self.name, &apos;at:&apos;, ctime()) self.res = self.func(*self.args) print(self.name, &apos;finished at:&apos;, ctime()) threading模块的其他函数除了各种同步和线程对象外，threading模块还提供了一些函数：active_count()：当前活动的Thread对象个数current_thread：返回当前的Thread对象enumerate()：返回当前活动的Thread对象列表settrace(func)：为所有线程设置一个trace函数setprofile(func)：为所有线程设置一个profile函数stack_size(size=0)：返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size 待续中。。。。。。]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Python线程与进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象——设计模式]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python设计模式一个定义：为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架，可以使得代码更加易于扩展和调用。四个基本要素：模式名称、问题、解决方案、效果。六大原则：1、开闭原则：一个软件实体,如类,模块和函数应该对扩展开发,对修改关闭.既软件实体应尽量在不修改原有代码的情况下进行扩展。2、里氏替换原则：所有引用父类的方法必须能透明的使用其子类的对象。3、依赖倒置原则：高层模块不应该依赖底层模块，二者都应该依赖其抽象，抽象不应该依赖于细节，细节应该依赖抽象，换而言之，要针对接口编程而不是针对实现编程。4、接口隔离原则：使用多个专门的接口,而不是使用单一的总接口，即客户端不应该依赖那些并不需要的接口。5、迪米特法则：一个软件实体应该尽可能的少与其他实体相互作用。6、单一直责原则：不要存在多个导致类变更的原因，即一个类只负责一项职责。比较流行的是：GOF23种设计模式。 设计模式——工厂模式工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。12345678910111213141516171819202122232425262728class CarFactory: def create_car(self, brand): if brand == &apos;奔驰&apos;: return Benz() elif brand == &apos;宝马&apos;: return BMW() elif brand == &apos;比亚迪&apos;: return BYD() else: return &apos;未知品牌，无法创建&apos;class Benz(): passclass BMW(): passclass BYD(): passfactory = CarFactory()c1 = factory.create_car(&apos;奔驰&apos;) c2 = factory.create_car(&apos;宝马&apos;)c3 = factory.create_car(&apos;比亚迪&apos;)print(c1)print(c2)print(c3) 打印结果如下：123&lt;__main__.Benz object at 0x0261EBD0&gt;&lt;__main__.BMW object at 0x0261E9F0&gt;&lt;__main__.BYD object at 0x0261ECB0&gt; 设计模式——单例模式单例模式（Singleton Pattern）的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久驻留在内存中，从而极大的降低开销。1234567891011121314151617181920class MySingleton: __obj = None # 类属性 __init_flag = True def __new__(cls, *args, **kwargs): if cls.__obj == None: cls.__obj = object.__new__(cls) return cls.__obj def __init__(self, name): if MySingleton.__init_flag: print(&quot;init.......&quot;) self.name = name MySingleton.__init_flag = False a = MySingleton(&apos;aa&apos;)b = MySingleton(&apos;bb&apos;)print(a)print(b) 打印结果如下：123init.......&lt;__main__.MySingleton object at 0x0305E250&gt;&lt;__main__.MySingleton object at 0x0305E250&gt; 工厂模式和单例模式的整合应用1234567891011121314151617181920212223242526272829303132333435363738394041class CarFactory: __obj = None # 类属性 __init_flag = True def create_car(self, brand): if brand == &apos;奔驰&apos;: return Benz() elif brand == &apos;宝马&apos;: return BMW() elif brand == &apos;比亚迪&apos;: return BYD() else: return &apos;未知品牌，无法创建&apos; def __new__(cls, *args, **kwargs): if cls.__obj == None: cls.__obj = object.__new__(cls) return cls.__obj def __init__(self): if CarFactory.__init_flag: print(&quot;init CarFactory.......&quot;) CarFactory.__init_flag = Falseclass Benz(): passclass BMW(): passclass BYD(): pass factory = CarFactory()c1 = factory.create_car(&apos;奔驰&apos;) c2 = factory.create_car(&apos;宝马&apos;)c3 = factory.create_car(&apos;比亚迪&apos;)print(c1, c2, c3)factory2 = CarFactory()print(factory)print(factory2) 打印结果如下啊：1234init CarFactory.......&lt;__main__.Benz object at 0x02E2ECF0&gt; &lt;__main__.BMW object at 0x02E2EC30&gt; &lt;__main__.BYD object at 0x02E2ED10&gt;&lt;__main__.CarFactory object at 0x02CBA450&gt;&lt;__main__.CarFactory object at 0x02CBA450&gt; 参考有：Python设计模式]]></content>
      <categories>
        <category>Python面向对象</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫之——认识urllib库]]></title>
    <url>%2F2019%2F04%2F07%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86urllib%E5%BA%93%2F</url>
    <content type="text"><![CDATA[不说废话，耿直，直接上案例。 案例1：百度首页爬取1234567891011121314151617# 导包from urllib import request# 确定爬取资源base_url = &apos;http://www.baidu.com&apos;# 构建请求 发送请求response = request.urlopen(base_url)# 接受响应信息html = response.read().decode(&apos;utf-8&apos;)print(html) # 返回的是html源代码 # 信息存储with open(&apos;./baidu.html&apos;,&apos;w&apos;,encodeing=&apos;utf-8&apos;) as f: f.wirte(html) ``` ### 案例2：get请求中url带中文字符实现百度搜索。url地址会将url中的中文字符进行编码，所以当我们使用urllib发送此类url请求前要讲中文字符进行编码。 from urllib import request, parse # 1.导包base_url = ‘http://www.baidu.com/s?&#39; # 2.确定爬取资源inp = input(‘输入搜索内容:’)msg = { # 3.构造请求参数 ‘wd’: inp}encodemsg = parse.urlencode(msg)newurl = base_url+encodemsg # 将编码后的参数进行拼接response = request.urlopen(newurl) #4. 构建请求 发送请求html = response.read().decode(‘utf-8’) # 5.接受响应信息print(html) # 返回的是html源代码with open(‘./baidu.html’, ‘w’, encodeing=’utf-8’) as f: # 信息存储 f.wirte(html)1234### 案例3：带user-agent反爬的网站带有user-agent反爬的网站在发送请求之前必须要构建自己的请求头。 from urllib import request # 1.导包base_url = ‘http://www.xicidaili.com&#39; # 2.确定爬取资源headers = { # 3.构造请求头与请求 ‘User-Agent’: ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36’}req = request.Request(url=base_url, headers=headers)html = request.urlopen(req) # 4.发送请求with open(‘./xici.html’,’w’,encodeing=’utf-8’) as f: # 5.接受并存储信息 f.write(html)1234### 案例4：以上都是get请求 接下来做百度翻译(post请求)先通过抓包工具F12 newwork分析，找到翻译时发送的请求，因为是异步请求又是post请求，所以还要找到传递的参数。直接上代码： from urllib import request,parseimport ssl,jsonssl._create_default_https_context = ssl._create_unverified_context 确定爬取地址base_url = ‘https://fanyi.baidu.com/sug&#39;def fanyi(msg): dataform = { # 构造数据 ‘kw’: msg } newdataform = parse.urlencode(dataform) response = request.urlopen(url=base_url, data=bytes(newdataform, encoding=’utf-8’)) # 发送请求 res = response.read().decode(‘utf-8’) # 接受返回的数据 newres = json.loads(res) # print(json.loads(res), type(json.loads(res))) str = &apos;&apos; for item in newres[&apos;data&apos;]: str += item[&apos;v&apos;] + &apos;\n&apos; print(str) print(json.dumps(newres, indent=4, ensure_ascii=False)) # 将字典类型转换成字符串if name == “main“: while True: msg = input(‘请输入要翻译的单词：’) if msg == ‘q’: # 按q退出 break fanyi(msg)12注意：如果发送请求时出现如下错误： urllib.error.URLError: 1这是因为ssl 验证的错误，可以将下面代码粘贴，解决不进行验证： ssl._create_default_https_context = ssl._create_unverified_context` 练习：爬取百度贴吧，根据用户输入的贴吧名称，页码范围来爬取指定贴吧指定页数范围。爬取豆瓣电影的数据，这个是豆瓣电影的api:https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信之——socket套接字]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E2%80%94%E2%80%94socket%E5%A5%97%E6%8E%A5%E5%AD%97%2F</url>
    <content type="text"><![CDATA[什么是Socketsocket(简称 套接字)是一个网络通信的端点，它能实现不同主机间的进程通信，我们网络上各种各样大多数都是基于Socket来完成的通讯。 网络中进程之间如何通讯呢？首要解决的问题是如何确定你要和对方电脑上哪个进程进行通讯，这主要是利用协议，IP地址，端口标识网络的进程，然后通过这些标识进行通讯。 socket——UDP网络通讯使用socket创建UDP通讯的过程很简单，如下图：根据上图我们可以总结创建服务端和客户端的步骤，使用代码分别实现服务端和客户端：123456789101112131415161718服务端：1.创建套接字对象2.绑定ip地址和端口号3.接受消息4.返回消息5.关闭套接字import socket# 创建套接字udp_s = socket.socked(socket.AF_INET,socket.SOCK_DGRAM)# 绑定ip地址udp_s.bind((&apos;&apos;,8080))# 接受消息data,addr = udp_s.recvfrom(1024)print(data)# 关闭套接字udp_s.close() 123456789101112客户端：1.创建套接字对象2.发送消息3.关闭套接字对象import socekd# 创建套接字对象udp_c = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)# 发送消息udp_c.sendto(&apos;hello&apos;.encode(&apos;utf-8&apos;),(&apos;192.168.1.15&apos;,8080))# 关闭套接字udp_c.close() Socket–TCP网络通讯TCP通讯过程如下图：从图上可以看出，创建服务端通信需要经过：1234567891011121314151617181920212223242526272829301.创建套接字对象2.绑定ip地址和端口号3.监听4.接受消息5.返回消息6.关闭套接字import sockettcp_s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)tcp_s.bind((&apos;&apos;,8080))tcp_s.listen()s,addr = tcp_s.accept()data = s.recv(1024)print(data.decode(&apos;utf-8&apos;))s.send(&apos;hello&apos;.encode(&apos;utf-8))s.close()tcp_s.close()``` 创建客户端通信需要经过：``` 1.创建套接字对象2.创建连接3.发送消息4.关闭套接字对象import sockettcp_c = socket.socket(socket.AF_INET,socket.SOCK_STRAM)tcp_c.connect((&apos;192.168.1.15&apos;,8080))tcp_c.send(&apos;hello&apos;.encode(&apos;utf-8&apos;))tcp_c.close()]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>网络通信学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议之——UDP和TCP]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E2%80%94%E2%80%94UDP%E5%92%8CTCP%2F</url>
    <content type="text"><![CDATA[UDP协议和TCP协议UDP协议UDP：用户数据报协议，不可靠性，只是把应用程序传给IP层数据报送出去，但是不能保证他们是否能到达目的地，传输数据报前不用再客户端和服务器之间建立连接，并且没有超时重发机制，所以传输速度快。特点：安全性差，传输速度快，无序，大小有限制64kb。 TCP协议我们知道，在通讯之前，一定要先建立相关链接，才能发送数据。 下面是tcp建立连接 三次握手的概述：其中：ACK：确认标志，SYN：同步标志第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。完成三次握手，主机A与主机B开始传送数据。特点：安全性高，稳定性好，有序；速度相对较慢。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F04%2F06%2Fgit01%2F</url>
    <content type="text"><![CDATA[一张git版本控制常用命令图送给你Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。下面是一张关于git版本控制的常用命令表： 参考自：Git教程|菜鸟教程]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象——super()]]></title>
    <url>%2F2019%2F04%2F05%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94super%2F</url>
    <content type="text"><![CDATA[Python OOP中关于super()的描述在Python OOP实际应用中，有一个函数super()，通过这个函数可以允许继承父类的子类访问该父类中的方法。super()会在该子类当中单独返回一个父类的临时对象，然后允许你在该子类中调用该父类所拥有的方法。通常使用super()这个函数调用父类当中所构建的方法，这可以使你无需在子类中重写这些方法，并允许你使用最少的代码更改来替换父类。在对Python super()有了一个大致的认识后，下面说一说Python中关于各种继承（单继承、多继承）对super()的简单应用等。 Python单继承之super()首先来定义两个类：Rectangle、Square，通过这两个类来说明继承关系。定义类如下：12345678910111213141516171819202122232425262728293031class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, height): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.length def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return self.length &lt;&lt; 2square = Square(4) # 实例化正方形类print(square.area())rectangle = Rectangle(2, 4) # 实例化矩形类print(rectangle.area()) 通过此示例发现，这两个类是两个相互有关联的形状类：正方形是一种特殊的矩形， 但以上的代码似乎并没有展示出这种关系，因此这两个类具有重复的代码。找出了相关性，我们就可以通过这种相关性类实现继承的关系，通过继承减少代码的量的编写：1234567891011121314151617181920212223class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)square = Square(4) # 实例化正方形类print(square.area())rectangle = Rectangle(2, 4) # 实例化矩形类print(rectangle.area()) 在这里，我们使用了super()来调用Rectangle类的init ()，允许我们在Square类中使用它而不重复代码。 如下所示，核心功能在进行更改后仍然存在。因为Square和Rectangle . init ()方法非常相似，所以你可以使用super()从Square的方法中调用超类的. init ()方法（Rectangle . init ()）。 这里设置了.length和.width属性，即使您只需要为Square构造函数提供单个长度参数。当你运行它时，即使你的Square类没有显式地实现它，对.area()的调用将使用超类中的.area()方法并打印16. Square类从Rectangle继承.area() 方法。 super()在单继承中能为你做什么呢？与其他面向对象语言一样，它允许您在子类中调用父类的方法。这种情况的主要用例是扩展继承方法的功能。在下面的示例中，您将创建一个继承自Square的类Cube，并扩展.area()的功能（通过Square继承自Rectangle类）以计算Cube实例的表面积和体积：12345678910111213141516171819202122232425262728293031323334class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): &apos;&apos;&apos;计算表面积&apos;&apos;&apos; face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length 这时，让我们看一下边长为3的立方体的表面积和体积：123cube = Cube(3)print(cube.surface_area()) # 54print(cube.volume()) # 27 从上面可以看出，我们为Cube立方体类实现了两个方法：.surface_area()和.volume()。这两个计算都依赖于计算单个面的面积，因此您不必重新实现面积计算，而是使用super()来扩展面积计算。另外请注意，Cube类定义没有. init ()。因为Cube继承自Square，而. init ()并没有为Cube做任何不同的事情，所以你可以跳过定义它，并且将自动调用超类（Square）的. init ()。super()将委托对象返回给父类，因此您可以直接调用它所需的方法：super().area()。这不仅使我们不必重写面积计算方法，而且还允许我们在一个位置更改内部.area()逻辑。当你有一些继承自一个父类的子类时，这尤其有用。介绍了上面这些示例，下面我们探索一下super()它的机制。 super()机制我们发现，上面一系列的示例是在没有任何参数的情况下调用super()的，然而super()也可以使用两个参数：第一个是子类，第二个参数是作为该子类实例的对象。首先，让我们看两个示例，通过使用已有的类来展示操作第一个变量可以做什么：123456789101112131415161718192021class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super(Square, self).__init__(length, length) 在Python 3当中，super(Square，self)调用等同于无参数的super()调用。 第一个参数指的是子类Square，而第二个参数指的是Square对象，在这种情况下，它是self。 我们也可以使用其他类调用super()：1234567891011class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): &apos;&apos;&apos;计算表面积&apos;&apos;&apos; face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length 在此示例中，您将Square设置为super()的子类参数，而不是Cube。 这导致super()开始在实例层次结构中的Square上方的一个级别搜索匹配方法（在本例中为.area()方法），在本例中为Rectangle类。在此特定示例中，行为不会更改。 但想象一下Square还实现了一个你想要确保Cube不使用的.area()方法。 以这种方式调用super()可以让你这样做。第二个参数怎么样？请记住，这是一个对象，它是用作第一个参数的类的实例。例如，isinstance(Cube，Square)必须返回True。通过包含实例化对象，super()返回一个绑定方法：绑定到对象的方法，用来为方法提供对象的上下文，例如任何实例属性。如果未包含此参数，则返回的方法只是一个函数，与对象的上下文无关。（注意：super()不返回方法。它返回一个代理对象。它将调用正确的类方法，而不需要另外创建一个对象。） Python多继承之super()了解了单继承的super()和它的一些示例，下面，我们将开始了解多继承的一些概述和一些示例，这些示例将演示多继承如何工作以及super()如何启用该功能。 多继承概述Python支持多继承，其中子类可以从多个不必继承的超类（也称为兄弟类）继承。为了更好地说明多继承的实际应用，下面将展示如何通过三角形和正方形构建一个右金字塔（带有方形底座的金字塔）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height): self.base = base self.height = height def area(self): return self.base * self.height * 0.5class RightPyramid(Triangle, Square): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base # 倾斜高度：从物体底部中心（如金字塔）到其面部到该物体顶部的高度 self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area 此示例原来的基础上又声明了一个Triangle类和一个继承Square和Triangle的RightPyramid类。您将看到另一个使用super()的.area()方法，就像在单继承中一样，目的是用到在Rectangle类中一直定义的.perimeter()和.area()方法。但问题是两个超类（Triangle和Square）都定义了一个.area()。花一点时间思考在RightPyramid上调用.area()时会发生什么，然后尝试调用它，如下所示：12345678910pyramid = RightPyramid(2, 4)print(pyramid.area())# Traceback (most recent call last):# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 103, in &lt;module&gt;# print(pyramid.area())# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 99, in area# base_area = super().area()# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 88, in area# return self.base * self.height * 0.5# AttributeError: &apos;RightPyramid&apos; object has no attribute &apos;height&apos; 您是否猜测Python会尝试调用Triangle.area()？ 这是因为所谓的方法解析顺序在起作用。注意：我们怎么注意到Triangle.area()被调用了，而不是像我们希望的那样，Square.area()？ 如果查看回溯的最后一行（在AttributeError之前），您将看到对特定代码行的引用：1return self.base * self.height * 0.5 您可以将几何类中的这个方法认为是三角形面积公式。 或者，你可能已经找到Triangle和Rectangle类定义，并在Triangle.area()中看到了相同的代码。 方法解析顺序mro方法解析顺序告诉Python如何搜索继承来的方法，当你使用super()时，这回排上很大的用场，因为mro会告诉Python将使用super()以及以什么样的顺序来进行调用的方法。每个类都会有一个.mro的魔术属性，它允许我们检查顺序：123print(RightPyramid.__mro__) # 打印结果：(&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;object&apos;&gt;) 这告诉我们首先在Rightpyramid中搜索方法，然后在Triangle中搜索，然后在Square中搜索，然后在Rectangle中搜索，然后，如果没有找到，则在对象中搜索。 这里的问题是解释器在Square和Rectangle之前在Triangle中搜索.area()，并且在Triangle中找到.area()时，Python会调用它而不是你想要的那个。 因为Triangle.area()期望有.height和.base属性，所以Python会抛出AttributeError。 幸运的是，您可以控制MRO的构建方式。 只需更改RightPyramid类的签名，即可按所需顺序进行搜索，方法将正确解析：123456789101112class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area 请注意，RightPyramid使用Square类中的. init ()进行部分初始化。 这允许.area()在对象上使用.length，如设计的那样。 现在，您可以构建金字塔类，检查MRO并计算表面积：123pyramid = RightPyramid(2, 4)print(pyramid.area()) # 20.0print(RightPyramid.__mro__) # (&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;object&apos;&gt;) 您可以看到MRO现在是您所期望的，并且您也可以检查金字塔的表面积，这要归功于.area()和.perimeter()。 不过，这里仍然存在问题。为了简单起见，我在这个例子中故意设置了一些错误：第一个，可以说最重要的是，我有两个具有相同方法名称和签名的独立类。 这会导致方法解析问题，因为将调用MRO列表中遇到的.area()的第一个实例。 当您使用具有多重继承的super()时，必须设计您的类以进行协作。其中一点是确保您的方法是唯一的，以便通过签名确保方法是唯一的 - 无论是使用方法名称还是方法参数，在MRO中正确解析它们。 在这种情况下，为了避免对代码进行彻底检查，可以将Triangle类的.area()方法重命名为.tri_area()。这样，area方法可以继续使用类属性而不是使用外部参数：12345678910class Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return self.base * self.height * 0.5 让我们继续在RightPyramid类中使用它：12345678910111213141516class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area 这里的下一个问题是代码没有像Square对象那样的委托的Triangle对象，所以调用.area_2()会给我们一个AttributeError，因为.base和.height没有任何值。 你需要做两件事来解决这个问题： 1.使用super()调用的所有方法都需要调用其超类的该方法版本。 这意味着您需要将super(). init ()添加到Triangle和Rectangle的. init ()方法中。 2.重新设计所有. init ()调用以获取关键字字典。 请参阅下面的完整代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length, **kwargs): self.width = width self.length = length super().__init__(**kwargs) def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs)class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.lengthclass Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return self.base * self.height * 0.5class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[&quot;height&quot;] = slant_height kwargs[&quot;length&quot;] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area 此代码中存在许多重要差异： 1.kwargs在某些地方被修改（例如RightPyramid . init ()): 这将允许这些对象的用户仅使用对该特定对象有意义的参数来实例化它们。 2.在kwargs之前设置命名参数：你可以在RightPyramid . init ()中看到这个。 这具有从kwargs字典中去除特定键的简洁效果，因此当它在MRO中最终进行到object时，**kwargs为空。现在，当您使用这些更新的类时，您有：123pyramid = RightPyramid(base=2, slant_height=4)print(pyramid.area()) # 20print(pyramid.area_2()) # 20.0 起作用了！ 您已经使用super()成功追溯复杂的类层次结构，同时使用继承和组合来创建具有最少重新实现的新类。 多重继承替代方案如您所见，多重继承可能很有用，但也会导致非常复杂的情况和难以阅读的代码。 拥有整齐地从多个其他对象继承所有东西的对象也很少见。 如果您发现自己开始使用多重继承和复杂的类层次结构，那么值得问问自己是否可以通过使用组合而不是继承来实现更清晰，更易于理解的代码。 通过组合，您可以从一个称为mixin的专用简单类中为您的类添加非常特定的功能。 由于本文主要关注继承，因此我不会详细介绍组合以及如何在Python中使用它，但这里有一个使用VolumeMixin为我们的3D对象提供特定功能的简短示例 - 在这种情况下，是一个体积计算：1234567891011121314151617181920212223242526272829303132333435class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.widthclass Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class VolumeMixin(): def volume(self): return self.area() * self.heightclass Cube(VolumeMixin, Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def __init__(self, length): super().__init__(length) self.height = length def surface_area(self): face_area = super().area() return face_area * 6 def face_area(self): return super().area() 在这个例子中，代码被重新设计为包含一个名为VolumeMixin的mixin。 然后，Cube使用mixin并使Cube能够计算其体积，如下所示：123cube = Cube(2)print(cube.surface_area()) # 24print(cube.volume()) # 8 这个mixin可以在任何需要计算体积的类中以相同的方式使用，并且公式area*height返回正确的结果。 有关Python中面向对象编程和使用super()的更多信息，请查看以下资源： 官方的super()文档 由Raymond Hettinger写的Python的super()真的超赞 Python中面向对象的编程3 参考自：使用Python Super()为类提供继承支持 译者：javylee英文原文]]></content>
      <categories>
        <category>Python面向对象</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块——hashlib]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94hashlib%2F</url>
    <content type="text"><![CDATA[Python的hashlib提供了常见的摘要算法，如MD5，SHA1，SHA224，SHA256，SHA384，SHA512等等,用于加密数据。什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值： MD51234import hashlibmd5 = hashlib.md5(b&apos;how to use md5 in python hashlib?&apos;)password_md5 = md5.hexdigest()print(password_md5) # d26a53750bc40b38b65a520292f69306 如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：12345import hashlibmd5 = hashlib.md5()md5.update(b&apos;how to use md5 in &apos;)md5.update(b&apos;python hashlib?&apos;)print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306 MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似： SHA1SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。12345import hashlibsha1 = hashlib.sha1()sha1.update(b&apos;how to use sha1 in &apos;)sha1.update(b&apos;python hashlib?&apos;)print(sha1.hexdigest()) # 2c76b57293ce30acef38d98f6046927161b46a44 摘要算法应用任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：12345name | password--------+----------michael | 123456bob | abc999alice | alice2008 如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：12345username | password---------+---------------------------------michael | e10adc3949ba59abbe56e057f20f883ebob | 878ef96e86145580c38c87f0410ad153alice | 99b1c2188db85afee403b1536010c2c9 考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：123&apos;e10adc3949ba59abbe56e057f20f883e&apos;: &apos;123456&apos;&apos;21218cca77804d2ba1922c33e0151105&apos;: &apos;888888&apos;&apos;5f4dcc3b5aa765d61d8327deb882cf99&apos;: &apos;password&apos; 这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：1hashlib.md5(&quot;salt&quot;.encode(&quot;utf8&quot;)) 经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块——sys]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94sys%2F</url>
    <content type="text"><![CDATA[sys模块sys模块是与python解释器交互的一个接口。下面是常用的的一些接口解释：12345sys.argv 命令行参数List，第一个元素是程序本身路径sys.exit(n) 退出程序，正常退出时exit(0),错误退出sys.exit(1)sys.version 获取Python解释程序的版本信息sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站流量术语]]></title>
    <url>%2F2019%2F04%2F04%2FHTTP%E5%AD%A6%E4%B9%A003%2F</url>
    <content type="text"><![CDATA[网站统计一般以数值较大的IP,PV统计，比较好看。 IPIP即Internet Protocol，这里是指独立ip数，不同的ip地址的计算机访问网站时被计算的总次数。独立ip数是网站流量的一个重要指标。一般相同ip地址的客户端访问网站页面一天内只会被计算一次。这里的ip指的是是固定的公网ip。 PVpv（Page View）即是页面浏览量，不管客户端是不是相同，也不管ip是否相同，用户只要访问网站页面就会被计算PV，一次计算一个PV。pv的度量方法就是客户端从浏览器发出一个web请求（request），服务器接收请求返回一个页面给客户端，这样就产生一个pv。页面刷新一下，就是一个PV。 UVUV即unique visitor，同一个客户端（pc或移动端）访问网站被计算为一个访客。一天内相同的客户端访问同一个网站只计一次uv，uv是以cookie等技术为统计依据，实际统计存在误差。一台计算机可能有多人使用，因此uv也不是最准确的。 并发数并发数指系统同时能处理的请求数量，也反应了系统的负载能力。 响应时间响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。 QPSQuery Per Second：每秒查询数服务器在一秒内处理了多少个请求，显然数字越大代表服务器的负载越高，处理能力越强。 12345Http相关术语pv、ip、uv 假设公司有一座大厦，大厦有100人，每个人有一台电脑和一部手机，上网都是通过nat转换出口，每个人点击网站2次（发2次请求）, 请问对应的pv,uv,ip分别是多少？PV：页面浏览量, 400 100人 2个设备 访问2次 =400数uv：独立的客户, 200 100人2个设备=200数ip：独立IP, 1个 同一个NAT出口，独立IP为1]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文、URI]]></title>
    <url>%2F2019%2F04%2F03%2FHTTP%E5%AD%A6%E4%B9%A002%2F</url>
    <content type="text"><![CDATA[什么是http报文？它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。 HTTP请求报文由请求行，请求头部，空行，请求报文主体几个部分组成，即：12345起始行： &lt;method&gt; &lt;request-URL&gt; &lt;version&gt;头部： &lt;headers&gt;主体： &lt;entity-body&gt; HTTP响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：123状态行响应头(Response Header)响应正文 URIuri中文叫“统一资源标识符”，是一个用于标识某一互联网资源名称的字符串，在世界范围内标识定位某一个唯一信息资源。还有一个概念叫做URL，那什么是URL？URL简称统一资源定位符。那URL的组成部分是由协议, 域名:端口, 路径和文件名。url主要用在各种www客户端和服务器程序上，url可以用一种统一的格式来描述各种信息资源，包括文件，服务器地址和目录等。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介、特点、版本、请求方法、状态码]]></title>
    <url>%2F2019%2F04%2F03%2FHTTP%E5%AD%A6%E4%B9%A001%2F</url>
    <content type="text"><![CDATA[## 一、Web服务基础用户访问网站的基本流程： 1、双击浏览器，输入目标网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在目标域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用2、如果本地dns缓存和hosts文件都没有域名解析记录，系统就会把访问的网址解析请求发送给客户端设置的DNS服务器去解析，也叫做Local DNS，如果LDNS服务器的本地缓存有对应的解析记录就会直接返回给客户端IP地址，如果没有LDNS就会继续请求其他的DNS服务器3、LDNS继续从DNS系统的”.”(根)开始请求目标域名的解析，并且根据每个层级的DNS服务器系统进行系列的查找，最终在DNS网络上找到目标域名对应的授权DNS服务器。这个授权DNS服务器就是企业（个人）购买域名时用于管理域名解析的服务器，服务器上有对应的域名（IP）解析。4、此时授权的DNS服务器就会把目标对应的IP解析记录，例如（1.1.1.1）发送给LDNS5、此时LDNS会把解析记录发给浏览器，并且缓存域名和IP的解析记录，便于下一次更快的返回请求6、浏览器获得ip，请求对应的服务器，网站服务器接收到客户端的请求开始响应处理，将内容返回给浏览器。 二、HTTP协议全称是HyperText Tansfer Protocol,中文叫超文本传输协议，是互联网最常见的协议。 Http最重要的是www(World Wide Web)服务，也叫web服务器，中文叫“万维网”。 web服务端口默认是80，另外一个加密的www服务应用https默认端口是443，主要用于支付，网银相关业务。 三、HTTP协议的特点 1.HTTP协议是无状态的 就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。 2.多次HTTP请求 在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。 3.基于TCP协议 HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。 四、版本http协议诞生以来有若干个版本，主要是http/1.0 http/1.1 http/1.0规定浏览器和服务器只能保持短暂的连接，浏览器的每次请求都需要和服务器建立一个TCP连接，服务器完成请求后即断开TCP连接，服务器不跟踪每个链接，也不记录请求 http/1.1是对HTTP的缺陷进行重点修复，从可扩展性，缓存，带宽优化，持久连接，host头，错误通知等访问改进。 http/1.1支持长连接，增加了更多的请求头和响应头信息，例如配置请求头的Connection的值为keep-alive，表示请求结果返回后保持连接 五、Http请求方法在HTTP通信中，每个请求报文都包含一个方法，以告诉web服务器端需要执行哪些操作，这些动作被称为HTTP的请求方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 六、HTTP状态码HTTP状态码表示web服务器响应http请求状态的数字代码。 常见状态码以及作用： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 七、HTTP状态码的命令查看$ curl -I www.oldboyedu.com 参考自：https://pythonav.com/wiki/detail/3/34/和https://www.cnblogs.com/wxisme/p/6212797.html]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx多个虚拟主机]]></title>
    <url>%2F2019%2F04%2F03%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9303%2F</url>
    <content type="text"><![CDATA[## Nginx多个虚拟主机想象一下，如果网站部署者在部署网站时，每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。于是就有了解决这种局面的办法：虚拟主机。虚拟主机就是将一台服务器分割成了多个“虚拟服务器”，每个站点可以使用各自的硬盘空间，由于节省资源、省钱，许多网站使用虚拟主机来部署网站。虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。 虚拟主机类型12345678- 基于域名的虚拟主机通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。- 基于端口的虚拟主机通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000- 基于IP的虚拟主机通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果。 修改nginx.conf12345678910111213141516171819202122232425262728293031323334egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf#配置文件内容如下worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; sendfile on; keepalive_timeout 65; #虚拟主机1 server &#123; listen 80; server_name www.pyyuc.cn; location /&#123; root html/pyyuc; index index.html index.htm; &#125;&#125; #虚拟主机2 server &#123; listen 80; server_name www.pythonav.cn; location /&#123; root html/pythonav; index index.html index.htm; &#125;&#125; &#125; 1234[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx目录、部署站点]]></title>
    <url>%2F2019%2F04%2F03%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9302%2F</url>
    <content type="text"><![CDATA[一、nginx软件目录12[root@yc-virtual-machine /opt/nginx1-12 11:44:02]#lsclient_body_temp conf fastcgi_temp html logs proxy_temp sbin scgi_temp static uwsgi_temp conf 存放nginx所有配置文件的目录,主要nginx.conf html 存放nginx默认站点的目录，如index.html、error.html等 logs 存放nginx默认日志的目录，如error.log access.log sbin 存放nginx主命令的目录,sbin/nginx Nginx主配置文件/etc/nginx/nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号{}来表示开始与结束。123456CoreModule核心模块user www; #Nginx进程所使用的用户worker_processes 1; #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log /log/nginx/error.log #Nginx错误日志存放路径pid /var/run/nginx.pid #Nginx服务运行后产生的pid进程号 123456events事件模块events &#123; worker_connections //每个worker进程支持的最大连接数 use epool; //事件驱动模型, epoll默认&#125; 12345678910111213141516171819202122232425http内核模块// 公共的配置定义在http&#123;&#125;http &#123; //http层开始... // 使用Server配置网站, 每个Server&#123;&#125;代表一个网站(简称虚拟主机) &apos;server&apos; &#123; listen 80; // 监听端口, 默认80 server_name localhost; // 提供服务的域名或主机名 access_log host.access.log // 访问日志 // 控制网站访问路径 &apos;location&apos; / &#123; root /usr/share/nginx/html; // 存放网站代码路径 index index.html index.htm; // 服务器返回的默认页面文件 &#125; // 指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton error_page 500 502 503 504 /50x.html; &#125; ... //第二个虚拟主机配置 &apos;server&apos; &#123; ... &#125; include /etc/nginx/conf.d/*.conf; // 包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件&#125; // http层结束 二、部署nginx站点nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到1234location /&#123; root html; #这里是默认的站点html文件夹，也就是 /opt/nginx1-12/html/文件夹下的内容 index index.html index.htm; #站点首页文件名是index.html &#125; 如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可12[root@yc-virtual-machine /tmp 11:34:52]#ls /opt/nginx1-12/html/index.html jssts.jpeg lhy.mp4 man.jpg wget-log 至此，只需要通过域名/资源，即可访问1http://www.pyyuc.cn/index.html 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx简介、安装]]></title>
    <url>%2F2019%2F04%2F02%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9301%2F</url>
    <content type="text"><![CDATA[一、nginx出世2004年10月4日，为俄罗斯知名门户站点而开发的Web服务程序 Nginx 横空出世。Nginx程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市场，但Nginx最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。 二、nginx介绍 nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。 nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。 nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。 安装更为简单，方便，灵活。 支持高并发，能支持几万并发连接 资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M 可以做http反向代理和负载均衡 支持异步网络i/o事件模型epoll下面介绍nginx的安装与配置 三、安装配置nginx安装nginx前的依赖环境解决123456789101112131415#执行第一条语句即可yum install gcc patch libffi-devel python-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y#依赖简单介绍一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 编译安装nginx12345678910111213141.下载源码包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz2.解压缩源码tar -zxvf nginx-1.12.0.tar.gz3.配置，编译安装 开启nginx状态监测功能./configure --prefix=/opt/nginx112/ make &amp;&amp; make install 4.启动nginx，进入sbin目录,找到nginx启动命令cd sbin./nginx #启动./nginx -s stop #关闭./nginx -s reload #重新加载5.修改PATHPATH=$PATH:/opt/nginx112/ 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2018%2F11%2F19%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、Linux与Windows的区别体现在目录的结构和安全性上，Linux所有的命令是以文件形式存储的，在Linux系统当中一切皆为文件（常用的比如：普通文件、目录文件、链接文件、设备文件等）。二、目录含义/bin 存放普通用户的命令文件/boot 存放系统启动文件/cdrom 存放读取光盘/dev 存放设备相关文件/etc 存放配置文件/home 家目录/lib 库文件相关/lib64 64位库文件/lost+found 系统异常产生错误时，丢失文件放在这里/media 媒体文件/mnt 挂载目录/opt 安装软件时的默认目录/proc 内存中相关数据文件/root root用户登录的家目录/run 系统运行的时候用到的文件/sbin 超级管理员运行的文件/srv 服务启动之后需要访问的数据目录/sys 系统文件/tmp 临时文件/usr 应用程序存放目录/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件 三、相关命令查看命令（目录结构、路径）：. 当前路径.. 上一级路径cd .. 回到上一级cd 切换到家目录cd ~ 切换到家目录cd - 回到上一个你操作的那一个目录pwd 查看当前所在的目录是哪里ls 查看当前文件夹里面有什么 .bash_history 但凡是点开头的文件，都是隐藏文件 -a 所有文件（包括隐藏文件） -l 以列表的形式呈现 -h 可以让文件大小带上单位ll 相当于ls -alman 是帮助命令，比如：man ls或man cpnano 内置自带的文本编辑器（编辑文件用的）cat 查看文件内容more 对于内容较多的情况下用more支持分页，空格下一页head 加上-2是查看前几条tail 加上-2是查看后几条dmesg 查看系统接入设备信息top 查看运行状态sudo service network-manager restart 网络有线未托管sudo apt-get install vim操作命令（新建、复制粘贴剪切、删除）：mkdir 要创建的文件夹名字touch 要创建的文件名ln -s 创建软链接，ln -s 指定你想要创建的连接 放到哪个目录下面，ln -s 需要使用绝对路径的方式来创建。mv /路径/文件夹或文件 新名称 功能：既可以剪切也可以改名cp 路径 路径（从哪里~到哪里去）cp 默认只能够复制文件cp -r 可以复制文件夹cp -a 可以复制权限和所有属性rm -rf 指定文件夹或者文件名称 功能：用于删除文件或者目录查找命令（找文件、文件内容）：find 搜索文件的命令find 查找位置 -name 文件名find / -iname index.phpgrep 搜索文件里面符合条件的内容grep “字符串” 文件名grep -i “root”grep -v “root”挂载操作命令：sudo fdisk -l 查看当前系统有哪些挂载设备sudo mount 找到的设备路径 /mnt/cdrom 挂载sudo umount /mnt/cdrom(umount + 挂载的目录) 取消挂载 四、权限结构在Linux中，无论文件夹还是文件都是有权限的，通过在终端键入ls -l命令行可以看到每一行开始都有类似drwxrwxr-x的一串字符码，当中就包含有权限的标识。其中：第一位表示类型，即说明是文件夹(d)、文件(-)以及链接(l)中的哪一类型；后面的9位，每三位划分为一组作为权限位，从前往后这三个权限位分别标识所属主、所属组、其他用户的权限。指定类型(dl-) 权限位1(rwx) 权限位2(rwx) 权限位3(rwx)，其中r=&gt;read w=&gt;write x=&gt;可执行，r =&gt; 4, w =&gt; 2, x =&gt; 1。d rwx rwx r-x文件类型-所属主 所属组 其他 d rwx rwx rwx位数1,2,3 代表当前文件或者文件夹的所有者的权限设定:(所有者的权限 u,user) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行位数4,5,6 代表当前文件或者文件夹的所属组的权限设定:(所属组的权限 g ,group) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行位数7,8,9 代表其他用户对当前文件或者文件夹的的权限设定:(其他人的权限 o,other) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行更改权限rwx的任意组合共 8 种 情况：rwx =&gt; 7rw- =&gt; 6r-x =&gt; 5r– =&gt; 4-wx =&gt; 3-w- =&gt; 2–x =&gt; 1— =&gt; 0其中r =&gt; 4, w =&gt; 2, x =&gt; 1。例如：根目录下默认的文件夹权限为755（rwx r-x r-x） ，根目录下默认的文件权限为644（rw- r– r–），所有权限为777（rwx rwx rwx）关于权限更改的各种写法chmod 755 1.txtchmod -R 777 ceshi100(chmod -R 777 文件夹) # 递归更改这个文件夹里面的所有文件权限chmod u+r,g-w,o+x 1.txtchmod u=rwx 1.txt其中：u代表所有者 加一个r权限 (user)g代表所属组 减一个w权限 (group)o代表其他 加一个执行权限 (other)=&gt;对于目录来讲r 是否呈现里面的文件w 是否可以在里面创建文件或文件夹x cd 切不进来 不能访问这个目录=&gt;对于文件来讲r 可以看到文件内容w 可以更改删除文件及内容x 是否可以执行这个文件 ./abc.sh (*扩展)sudo useradd a01 添加新用户账号sudo passwd a01 为新用户设置密码sudo su a01 切换用户账号exit 退出当前用户 http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础总结]]></title>
    <url>%2F2018%2F11%2F17%2FPython%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、注释1、 注释的排错性 先注释一部分代码，然后执行另外一部分代码，查看报错，用于调试。2、注释的注意点 多行注释的嵌套： 如果外面是三个单引号，则里面要用三个双引号；如果外面是三个双引号，则里面要用三个单引号。二、变量1、概念：可以改变的量，具体是指内存中的一段存储空间。 house305 = “张三” print(house305) house305 = “李四” print(house305)2、变量的三种声明方式： 方式一 a = 1 b = 2 方式二 a, b = 1, 2 方式三 a = b = 3 (注意：这种方式的id(a) == id(b)) 3、变量的命名规范：字母数字下划线，首字母不能为数字。严格区分大小写，且不能使用关键字。变量命名有意义，且不能使用中文哦。import keywordprint(keyword.kwlist) # [‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]4、变量的交换a = 3b = 10a, b = b, aprint(a, b) # 10 3 三、Python的六大数据类型分为：Number型、容器类型（字符串型、列表型、元组型、集合型、字典型）。(1)Number数字类型(int float bool complex) ①Number类型之int 整型(正整数 0 负整数) intvar = 37 print(intvar) # type() 查看一个值的数据类型 res = type(intvar) print(res) #&lt;class &apos;int&apos;&gt; # id() 查看一个变量所指向值的地址 res = id(intvar) print(res) #10915520 # 二进制整型 intvar = 0b1010101 # 八进制整型 intvar = 0o127 # 十六进制整型 intvar = 0xFF # 变量声明的第三种方式 特点 a = b = 89 res1 = id(a) res2 = id(b) print(res1) print(res2) ②Number类型之float 浮点型 （小数：1普通小数 2科学计数法表示的小数。例:a = 3e-5 #3e-05 ） (1)表示方式一 floatvar = 3.14 (2)表示方式二 floatvar = 3.14e-2 # 小数点向左移动2位 floatvar = 3.14e04 # 小数点向右移动4位 ③Number类型之bool 布尔型 （True 真的 False 假的） boolvar = True boolvar = False ④Number类型之complex 复数类型（实数+虚数 组成） ‘&apos;&apos; 如果有一个数，它的平方是-1，那么这个数就是j (科学家认为有，表达一个高精度的类型) &apos;&apos;&apos; (1) 表达方式一 complexvar = 3 + 4j complexvar = 4j (2)表达方式二 &apos;&apos;&apos; var1 = complex(实数,虚数) 通过complex强制转换成复数类型 &apos;&apos;&apos; complexvar = complex(3, 5) （2）String字符串型特征：可获取，不可修改的有序容器类型数据。 # error strvar=&quot;这是真的字符串&quot; strvar[-3] = &quot;假&quot; print(strvar) 字符串有三种类型：通过单引号、双引号、三引号（可以支持跨行,不需要对单双引号进行转义）引起来的字符串。转义字符： 语法: \ + 字符 (1)将无意义的字符变得有意义 (2)将有意义的字符变得无意义 例如： \n 或者 \r\n : 代表换行 \t : 代表一个tab缩进(水平制表符) \r : 把\r后面的字符提到行首 strvar = “处处\r蚊子咬” print(strvar)元字符串：r+字符串：作用在于让转义字符失效，原型化输出 strvar = r’夜来\n大狗熊’ print(strvar) strvar = r”夜来\n大狗熊” print(strvar) strvar = r’’’夜来\n大狗熊’’’ print(strvar) strvar = r”””夜来\n大狗\r熊\t””” print(strvar)（3）List列表类型特征：可获取，可修改de有序容器类型数据。定义空列表： listvar = [] print(listvar)列表值的获取： listvar = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’] res = listvar[1] res = listvar[len(listvar) - 1]列表的修改： listvar = [‘a’, 14, 3,14, True, 4 + 3j] listvar[1] = “15”（4）Tuple元组类型特征：可获取，不可修改的有序的容器类型数据定义空元组： tuplevar = ()tuple类型的获取： tuplevar = (‘a’, ‘c’, ‘b’, ‘s’, 15 - 9j, False) res = tuplevar[-3]tuple类型不支持修改 # error tuplevar[0] = 1234 print(tuplevar) (5)Set集合类型特征：自动去重，无序的容器类型数据。作用：集合类型是用来做交集、差集、并集、补集操作的。注意点：无法通过索引来获取其中的数据。 setvar = {True, “你好”, 34, 9.2, 3 + 4j} print(setvar) print(setvar[1]) # error无法修改集合当中的值 setvar[0] = “999” # error print(setvar)单独定义一个{} 它代表的不是集合 而是字典 var = {} # 空字典 print(type(var)) #dict var = set() # 空集合 print(type(var))(6)Dict字典类型特征：键值对存储的，无序容器类型数据。dictvar = {‘top’: ‘程咬金’, ‘middle’: ‘貂蝉’, ‘bottm’: ‘鲁班七号’, ‘support’: ‘蔡文姬’, ‘jungle’: ‘韩信’}字典的获取：通过键获取值 res = dictvar[‘jungle’] print(res)字典的修改 dictvar[‘middle’] = ‘小乔’ print(dictvar) 四、类型转换–&gt;自动类型转换当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高:bool、int、float、complex。–&gt;强制类型转换Number类型强制转换通过int()、float()、complex()可以将整型、浮点型、布尔型以及纯数字字符串强转为对应的类型数据，而通过bool()则可以将Number类型数据和容器类型数据强转为bool类型数据。（扩展：布尔类型为假的时候，一共有10种情况：0, 0.0, False, 0j, ‘’, [], (), {}, set(), None）容器类型强制转换通过str()可以将Number类型和容器类型强制转为String型。通过list()可以将字符串、列表、元组、集合、字典类型强制转换为List类型，把字典强转成列表,只要其中的键,忽略其中的值。通过tuple()可以将容器类型数据强转为tuple类型数据，把字典强转成列表,只要其中的键,忽略其中的值。通过set()可以将容器类型数据强制转换为集合类型数据，把字典强转成集合,只要其中的键,忽略其中的值。dict()使用 二级列表 或 二级元组 (二级集合语法上不错,但是无序,不建议使用)‘’’强转成字典的条件：需要等长的二级容器’’’ 方式一var1 = [(“a”: 1), (“b”, 2)]var2 = [[‘a’: 3], [‘b’: 4]]var3 = [(‘a’: 5), [‘b’: 6]] var4 = [{‘a’: 7}, {‘b’: 8}]res = print(var4)print(res, type(res)) 方式二var1 = ((‘a’, 1), (‘b’, 2))var2 = ([‘a’, 3], [‘b’, 4])var3 = ((‘a’, 5), [‘b’, 6]) var4 = [{‘a’,7},{‘b’,8}] 切记不要使用res = dict(var4)print(res) 方式三var = {(‘a’, 1), (‘b’, 2)}res = dict(var)print(res) 五、以下数据类型存储规律仅对当前linux 64位的python3.x版本负责–&gt;Number 部分1.对于整型而言，-5~正无穷范围内的相同值 id一致2.对于浮点数而言，非负数范围内的相同值 id一致3.布尔值而言,值相同情况下，id一致4.复数的id标识都不相同(在 实数+虚数 这样的结构中)–&gt;容器类型部分5.字符串而言，字符串值相同情况下，id一致6.列表，元组，字典，集合无论什么情况 id标识都不同(但空元组的id标识一样) 六、Python运算符(1)算数运算符: + - / // % **(2)比较运算符: &gt; &lt; &gt;= &lt;= == !=(3)赋值运算符: = += -= = /= //= %= **=(4)成员运算符: in 和 not in (针对于容器型数据)(5)身份运算符: is 和 is not (检测两个数据在内存当中是否是同一个值)(6)逻辑运算符: and or notTrue and print(1)False and print(2) # 逻辑与短路True or print(3) # 逻辑或短路False or print(4)(7)位运算符: &amp; | ~ ^ &lt;&lt; &gt;&gt;按位非是对补码进行操作的，每一位按位取反，包括高位符号位(注意：原码和补码之间的互相转换，符号位不动)运算规律：公式：-(x + 1)例如：~19补码: 00000000 10011按位非: 11111111 01100给补码求原码:取反:1111111 10011加1 :1111111 10100 (原码)最终: -20~(-19)原码：11111111 10011给原码求补码：取反：11111111 01100加一：11111111 01101按位非运算： 00000000 10010最终：18运算符的优先级：一元运算符优先级 大于 二元运算符 一元运算符（~按位非 -负号） 例：~19只对一个数进行操作的运算符叫做一元运算符 二元运算符 例：1 + 2 对两个数 进行操作的运算符叫做二元运算符运算符优先级最低的是 赋值运算符当中的=运算符整体的优先顺序如下： 算数运算符 &gt; 位运算符 &gt; 比较运算符 &gt; 赋值运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 七、流程控制大致分为三种控制结构：顺序结构、分支结构、循环结构。分支结构分为：单项分支、双项分支、多项分支、巢状分支，通过if elif else关键字来构建。循环结构分为while / for… in…，通过循环结构可以减少代码的冗余，提高执行效率。for…in…循环多用于遍历容器类型数据，而while则不能遍历无序的容器类型数据。在遍历字典时，默认遍历字典的键。遍历等长的二级列表： listvar = [[‘a’, ‘b’, ‘c’], [‘d’, ‘e’, ‘f’], [‘g’, ‘h’, ‘j’]] for i, j, k in listvar: print(i, j, k)字符串的拼接：–&gt;正常拼接：通过“+”来拼接。 a = ‘1’ b = ‘2’ print(a + b)–&gt;跨行拼接：通过\来衔接不同的多行。 strvar = “123456”\ “7890”–&gt;重复拼接：通过字符 次数。 strvar = ‘love’ 10 pass用来占位 / break终止当前循环，只能用在循环当中 / continue跳过当前循环，后面的代码不执行，直接从下一次循环开始 八、函数关于函数(1)函数的含义:功能 (包裹一部分代码 实现某一个功能 达成某一个目的)(2)函数特点:可以反复调用,提高代码的复用性,提高开发效率,便于维护管理(3)函数基本格式 def func(): pass(4)驼峰命名法：（便于程序员更为方便的阅读代码）大驼峰命名法：MyCar（用在类的命名中）；小驼峰命名法：myCar（一般用在函数命名中）；普通情况下，一般用_来分割不同的词。 # 99乘法表的定义 def multiplication99_table(): for i in range(1, 10):; for j in range(1, i + 1): print(&quot;%d*%d=%2d &quot; % (i, j, i*j), end=&quot;&quot;) print() # 99乘法表的调用 multiplication99_table() 关于函数参数(1)函数参数概念及分类 函数参数:调用时需要传递的数据. 函数参数大类分为形参和实参: 形参: 在函数定义时，括号里面的参数，叫形参（形式参数） 实参: 在函数调用时，括号里面的参数，叫实参（实际参数） 形参与实参的关系:函数调用时,形参和实参个数需要一一对应 形参种类:普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数 实参种类:普通实参,关键字实参 默认形参和关键字实参区别：默认形参和关键字实参写法上一样，只不过默认形参在函数的定义处，关键字实参在函数的调用处。(2)收集参数: 普通收集参数:在形参当中，号后面的参数是收集参数，用于专门收集多余的普通参数,形成一个新的元组。语法:参数前面加 例:*args。 # 例子：计算任意个数的累加和 def my_sum(*args): total = 0 for i in args: total += i print(total) my_sum(1, 2, 3, 77, 11) 关键字收集参数:用于专门收集多余关键字实参的是关键字收集参数,形成一个新的字典。语法:参数前面加** 例:**kwargs。 # 例子：任意参数的拼接 def link_str(**kwargs): print(kwargs)#{&apos;monitor&apos;:&apos;zhangbojin&apos;,&apos;zhangsan&apos;:&apos;zhangsan&apos;,&apos;school_beauty&apos;:&apos;wangitechui&apos;} strvar1 = &apos;&apos; strvar2 = &apos;&apos; keydict = {&apos;monitor&apos;:&apos;班长&apos;,&apos;school_beauty&apos;:&apos;校花&apos;} for key,val in kwargs.items(): if key in keydict: strvar1 += keydict[key] + val + &apos;\n&apos; else: strvar2 += val print(strvar1+&quot;今天结婚,喜结良缘&quot;+&quot;,到场的吃瓜群众是&quot;+strvar2) link_str(monitor=&quot; 张铂金 &quot;,school_beauty=&quot; 王铁锤 &quot;,zhangsan = &apos;张三&apos; ) (3)命名关键字参数:定义时放在号后面的参数,调用时强制必须指定关键字实参才能调。在函数定义时，写在后面的参数2是命名关键字参数（假定参数3是关键字收集参数）语法:(*,x) x是命名关键字参数。作用：在函数调用的时候，必须使用关键字实参进行调用**保证参数3不是关键字收集参数时，那么此刻参数2，参数3都是命名关键字参数 (4)关于和**的 实参 调用:在调用时,容器类型数据前面加 或者 在函数的调用处：例：func2(*listvar, dictvar) 用在修改容器类型的数据，把容器里面的数据，一个一个拿出来，当成参数传递给函数** 用在修饰字典类型的数据，意味着把字典中的{键: 值} =&gt;变成键=值,一个个当成参数赋值给函数调用小案例 def func(a,b,*args,c,d):print(a,b) print(args) print(c) print(d) func(1,2,3,4,5,c=6,d=999)*号用法 print(“======”) listvar = [1, 2, 3] func1(*listvar)func1(*listvar) 等价于 func1(1, 2, 3)**号用法 dictvar = {‘d’: 4} func2(1, 2, 3, **dictvar)func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)函数的调用处 func2(listvar,**dictvar)(5)形参声明的位置顺序: 普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt; 命名关键字参数 -&gt; 关键字收集参数(6)对于任意函数，都可以通过 def func(args, **kw) 来获取所有参数参数练习：def f1(a, b, c=0, args, **kwargs): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)def f2(a, b, c=0, , d, *kw): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘d =’, d, ‘kw =’, kw)以上两个函数 打印结果#(一)f1(1, 2) #a = 1 b = 2 c = 0 args = () kw = {}f1(1, 2, c=3) #a = 1 b = 2 c = 3 args = () kw = {}f1(1, 2, 3, ‘a’, ‘b’) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {}f1(1, 2, 3, ‘a’, ‘b’, x=99) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99}f2(1, 2, d=99, ext=None) #a = 1 b = 2 c = 0 d = 99 kw = {‘ext’: None}#(二)args = (1, 2, 3, 4)kw = {‘d’: 99, ‘x’: ‘#’}f1(*args, **kw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}f1(1,2,3,4,d=99,x=’#’)#(三)myargs = (1, 2, 3)mykw = {‘d’: 88, ‘x’: ‘#’}f2(*myargs, **mykw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}f2(1,2,3,d=88,x=’#’)#(四)def f1(a, b, c=0, *args,d,**kw): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw) print(d)f1(1,2,3, ‘a’, ‘b’,d=67, x=99,y=77) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99, ‘y’: 77} return返回值为这个函数返回一个结果 (return返回值可有可无 按照需求选择)注意:执行return语句之后,函数执行结束 doc：doc或者help查看文档 全局变量、局部变量及其关键字的使用– global 关键字:声明全局变量,作用在于修改全局变量– nonlocal 关键字:声明函数内部的局部变量,作用在于修改局部变量(当前函数上一层的局部变量) 内部函数(1)内部函数可以直接在函数外部调用么(2)调用外部函数后,内部函数可以在函数外部调用吗(3)内部函数可以在函数内部调用吗(4)内部函数在函数内部调用时,是否有先后顺序 闭包闭包的定义:内函数使用外函数的局部变量，并且外函数将内函数返回出来的方法叫闭包,返回的内函数叫闭包函数。闭包的特点:外函数的临时变量会在将来的内部函数中用到,自己调用结束后会把外函数的临时变量与内函数绑定,不释放将来调用内函数的时候仍可使用外函数变量。闭包的意义:闭包可以优先使用外函数中的变量,并对闭包中的值起到了封装保护的作用.外部无法访问。 递归函数递归的定义：自己调用自己就是递归函数。递归的注意事项：函数调用的过程就是开辟栈帧和释放栈帧的过程，调用结束时开辟栈帧空间，结束时释放（话外之意是不结束这层栈帧不释放）。递归每次调用都会开辟一个栈帧，如果递归的层数过多，不建议使用，容易内存溢出。每次开辟的栈帧空间，代码必须全部执行完毕之后才释放空间，在回到上一个栈帧执行没结束的代码。如果使用递归，需要给予一个跳出的条件，不能无限递归。 匿名函数实际上就是通过lambda表达式来书写的。一般只用来实现一些简单的函数功能，写法非常方便。 迭代器：定义：能被next()函数调用并且不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）。特征：迭代器会生成惰性序列，它通过计算把值依次地返回，一边循环一边计算而不是一次性得到所有数据。优点：需要数据的时候，一次取一个，可以大大节省内存空间，而不是一股脑地把所有数据放进内存。‘惰性序列：没有一次性的把所有数据都放在序列中，而是遍历一个放一个，这样的序列叫做惰性序列。Iterable可迭代性 Iterator迭代器range是可迭代对象range和迭代器能够产生惰性序列]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python OS模块常用方法总结]]></title>
    <url>%2F2018%2F10%2F14%2FPython%20OS%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[os模块是与操作系统交互的一个接口。下面是关于对文件路径、文件夹等的相关操作及说明。 操作 说明 os.getcwd() 得到当前工作目录，即当前Python脚本工作的目录路径 os.listdir() 返回指定目录下的所有文件和目录名 os.remove() 函数用来删除一个文件 os.removedirs(r”c\python”) 删除多个目录 os.path.isfile() 检验给出的路径是否是一个文件 os.path.isdir() 检验给出的路径是否是一个目录 os.path.isabs() 判断是否是绝对路径 os.path.exists() 检验给出的路径是否真地存 os.path.split() 返回一个路径的目录名和文件名 os.path.splitext() 分离扩展名 os.path.dirname() 获取路径名 os.path.basename() 获取文件名 os.system() 运行shell命令 os.getenv()与os.putenv() 读取和设置环境变量 os.linesep 给出当前平台使用的行终止符，Windows使用’rn’，Linux使用’n’而Mac使用’r’ os.name 指示你正在使用的平台，对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ os.rename(old, new) 重命名： os.makedirs(r”c：\python\test”) 创建多级目录 os.mkdir(“test”) 创建单个目录 os.stat(file) 获取文件属性 os.chmod(file) 修改文件权限与时间戳 os.exit() 终止当前进程 os.path.getsize(filename) 获取文件大小 os.mkdir(“file”) 创建目录 os.rename(“oldname”,”newname”) 重命名文件（目录）,文件或目录都是使用这条命令 os.remove(“file”) 删除文件 os.rmdir(“dir”) 删除目录, 只能删除空目录 os.chdir(“path”) 转换目录, 换路径 os.mknod(“test.txt”) 创建空文件]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5/CSS3新特性、移除的元素及兼容问题]]></title>
    <url>%2F2018%2F10%2F14%2FHTML5CSS3_001%2F</url>
    <content type="text"><![CDATA[HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有： 绘画canvas元素 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、searchCSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。移除的元素包括： 纯表现的元素 basefont、big、center、font、 s、strike、tt、u； 对可用性产生负面影响的元素 frame、frameset、noframes。浏览器兼容问题解决方案：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式，当然最好的方式是直接使用成熟的框架： 123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
</search>
