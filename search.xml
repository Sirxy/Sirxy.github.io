<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程编程——threading模块]]></title>
    <url>%2F2019%2F04%2F09%2Fthreading%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[threading模块的Thread类threading模块的Thread类是主要的执行对象。它有thread模块中没有的许多函数。使用Thread类可以有很多方法来创建线程。这里介绍其中比较相似的三种方法。 方法一：创建Thread的实例，传给它一个函数。如下啊：1234567891011121314151617181920212223242526272829import threadingfrom time import sleep, ctimeloops = [4, 2]def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，打印结果如下：1234567starting at: Wed Apr 10 16:28:53 2019start loop 0 at: Wed Apr 10 16:28:53 2019start loop 1 at: Wed Apr 10 16:28:53 2019loop 1 done at: Wed Apr 10 16:28:55 2019loop 0 done at: Wed Apr 10 16:28:57 2019all done at: Wed Apr 10 16:28:57 2019[Finished in 4.2s] 方法二：创建Thread的实例，传给它一个可调用的类实例在创建线程时，与传入函数相似的一个方法是传入一个可调用的类的实例，用于线程执行——这种方法更加接近面向对象的多线程编程。这种可调用的类包含一个执行环境，比起一个函数或者从一组函数中选择而言，有更好的灵活性。现在你有了一个类对象，而不仅仅是单个函数或者一个函数列表/元组。在方法一的代码中添加一个新类ThreadFunc，并进行一些其他的轻微改动，得到下面的代码：123456789101112131415161718192021222324252627282930313233343536373839import threadingfrom time import sleep, ctimeloops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=&apos;&apos;): self.name = name self.func = func self.args = args def __call__(self): self.func(*self.args)def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # create all threads t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__)) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，得到了如下的输出：1234567starting at: Wed Apr 10 16:51:55 2019start loop 0 at: Wed Apr 10 16:51:55 2019start loop 1 at: Wed Apr 10 16:51:55 2019loop 1 done at: Wed Apr 10 16:51:57 2019loop 0 done at: Wed Apr 10 16:51:59 2019all done at: Wed Apr 10 16:51:59 2019[Finished in 4.2s] 方法三：派生Thread的子类，并创建子类的实例这种方法要介绍的这个例子要调用Thread()的子类（实际上就是继承Thread类鞭编写我们自己需要的线程类），和上一个创建可调用类的例子有些类似。当创建线程时使用子类要相对更容易阅读。 12345678910111213141516171819202122232425262728293031323334353637383940import threadingfrom time import sleep, ctimeloops = [4, 2]class MyThread(threading.Thread): # 继承 def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) # 必须调用基类的构造函数 self.name = name self.func = func self.args = args def run(self): self.func(*self.args)def loop(nloop, nsec): print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime()) sleep(nsec) print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())def main(): print(&apos;starting at:&apos;, ctime()) threads = [] nloops = range(len(loops)) for i in nloops: # create all threads t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in nloops: # start threads threads[i].start() for i in nloops: # wait for all threads to finish threads[i].join() print(&apos;all Done at:&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 当运行完后，得到了如下的输出：1234567starting at: Wed Apr 10 17:07:01 2019start loop 0 at: Wed Apr 10 17:07:01 2019start loop 1 at: Wed Apr 10 17:07:01 2019loop 1 done at: Wed Apr 10 17:07:03 2019loop 0 done at: Wed Apr 10 17:07:05 2019all Done at: Wed Apr 10 17:07:05 2019[Finished in 4.2s] 本例中将对Thread子类化，而不是直接对齐实例化。这将使我们在定制线程对象时拥有更多的灵活性，也能够简化线程创建的调用过程。 现在对MyThread类进行修改，增加一些调试信息的输出，并将其存储为一个名为myThread的独立模块，以便于后面自己用到这个类。myThread.py：123456789101112131415161718import threadingfrom time import sleep, ctimeclass MyThread(threading.Thread): def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) # 必须调用基类的构造函数 self.name = name self.func = func self.args = args def getResult(self): return self.res def run(self): print(&apos;starting&apos;, self.name, &apos;at:&apos;, ctime()) self.res = self.func(*self.args) print(self.name, &apos;finished at:&apos;, ctime()) threading模块的其他函数除了各种同步和线程对象外，threading模块还提供了一些函数：active_count() 当前活动的Thread对象个数current_thread 返回当前的Thread对象enumerate() 返回当前活动的Thread对象列表settrace(func) 为所有线程设置一个trace函数setprofile(func) 为所有线程设置一个profile函数stack_size(size=0) 返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size|函数|描述||—|—||active_count()|当前活动的Thread对象个数||current_thread |返回当前的Thread对象||enumerate()|返回当前活动的Thread对象列表||settrace(func)|为所有线程设置一个trace函数||setprofile(func)|为所有线程设置一个profile函数||stack_size(size=0)|返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size|]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Python线程与进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象——设计模式]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python设计模式一个定义：为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架，可以使得代码更加易于扩展和调用。四个基本要素：模式名称、问题、解决方案、效果。六大原则：1、开闭原则：一个软件实体,如类,模块和函数应该对扩展开发,对修改关闭.既软件实体应尽量在不修改原有代码的情况下进行扩展。2、里氏替换原则：所有引用父类的方法必须能透明的使用其子类的对象。3、依赖倒置原则：高层模块不应该依赖底层模块，二者都应该依赖其抽象，抽象不应该依赖于细节，细节应该依赖抽象，换而言之，要针对接口编程而不是针对实现编程。4、接口隔离原则：使用多个专门的接口,而不是使用单一的总接口，即客户端不应该依赖那些并不需要的接口。5、迪米特法则：一个软件实体应该尽可能的少与其他实体相互作用。6、单一直责原则：不要存在多个导致类变更的原因，即一个类只负责一项职责。比较流行的是：GOF23种设计模式。 设计模式——工厂模式工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。12345678910111213141516171819202122232425262728class CarFactory: def create_car(self, brand): if brand == &apos;奔驰&apos;: return Benz() elif brand == &apos;宝马&apos;: return BMW() elif brand == &apos;比亚迪&apos;: return BYD() else: return &apos;未知品牌，无法创建&apos;class Benz(): passclass BMW(): passclass BYD(): passfactory = CarFactory()c1 = factory.create_car(&apos;奔驰&apos;) c2 = factory.create_car(&apos;宝马&apos;)c3 = factory.create_car(&apos;比亚迪&apos;)print(c1)print(c2)print(c3) 打印结果如下：123&lt;__main__.Benz object at 0x0261EBD0&gt;&lt;__main__.BMW object at 0x0261E9F0&gt;&lt;__main__.BYD object at 0x0261ECB0&gt; 设计模式——单例模式单例模式（Singleton Pattern）的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久驻留在内存中，从而极大的降低开销。1234567891011121314151617181920class MySingleton: __obj = None # 类属性 __init_flag = True def __new__(cls, *args, **kwargs): if cls.__obj == None: cls.__obj = object.__new__(cls) return cls.__obj def __init__(self, name): if MySingleton.__init_flag: print(&quot;init.......&quot;) self.name = name MySingleton.__init_flag = False a = MySingleton(&apos;aa&apos;)b = MySingleton(&apos;bb&apos;)print(a)print(b) 打印结果如下：123init.......&lt;__main__.MySingleton object at 0x0305E250&gt;&lt;__main__.MySingleton object at 0x0305E250&gt; 工厂模式和单例模式的整合应用1234567891011121314151617181920212223242526272829303132333435363738394041class CarFactory: __obj = None # 类属性 __init_flag = True def create_car(self, brand): if brand == &apos;奔驰&apos;: return Benz() elif brand == &apos;宝马&apos;: return BMW() elif brand == &apos;比亚迪&apos;: return BYD() else: return &apos;未知品牌，无法创建&apos; def __new__(cls, *args, **kwargs): if cls.__obj == None: cls.__obj = object.__new__(cls) return cls.__obj def __init__(self): if CarFactory.__init_flag: print(&quot;init CarFactory.......&quot;) CarFactory.__init_flag = Falseclass Benz(): passclass BMW(): passclass BYD(): pass factory = CarFactory()c1 = factory.create_car(&apos;奔驰&apos;) c2 = factory.create_car(&apos;宝马&apos;)c3 = factory.create_car(&apos;比亚迪&apos;)print(c1, c2, c3)factory2 = CarFactory()print(factory)print(factory2) 打印结果如下啊：1234init CarFactory.......&lt;__main__.Benz object at 0x02E2ECF0&gt; &lt;__main__.BMW object at 0x02E2EC30&gt; &lt;__main__.BYD object at 0x02E2ED10&gt;&lt;__main__.CarFactory object at 0x02CBA450&gt;&lt;__main__.CarFactory object at 0x02CBA450&gt; 参考有：Python设计模式]]></content>
      <categories>
        <category>Python面向对象</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫之——认识urllib库]]></title>
    <url>%2F2019%2F04%2F07%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86urllib%E5%BA%93%2F</url>
    <content type="text"><![CDATA[不说废话，耿直，直接上案例。 案例1：百度首页爬取1234567891011121314151617# 导包from urllib import request# 确定爬取资源base_url = &apos;http://www.baidu.com&apos;# 构建请求 发送请求response = request.urlopen(base_url)# 接受响应信息html = response.read().decode(&apos;utf-8&apos;)print(html) # 返回的是html源代码 # 信息存储with open(&apos;./baidu.html&apos;,&apos;w&apos;,encodeing=&apos;utf-8&apos;) as f: f.wirte(html) ``` ### 案例2：get请求中url带中文字符实现百度搜索。url地址会将url中的中文字符进行编码，所以当我们使用urllib发送此类url请求前要讲中文字符进行编码。 from urllib import request, parse # 1.导包base_url = ‘http://www.baidu.com/s?&#39; # 2.确定爬取资源inp = input(‘输入搜索内容:’)msg = { # 3.构造请求参数 ‘wd’: inp}encodemsg = parse.urlencode(msg)newurl = base_url+encodemsg # 将编码后的参数进行拼接response = request.urlopen(newurl) #4. 构建请求 发送请求html = response.read().decode(‘utf-8’) # 5.接受响应信息print(html) # 返回的是html源代码with open(‘./baidu.html’, ‘w’, encodeing=’utf-8’) as f: # 信息存储 f.wirte(html)1234### 案例3：带user-agent反爬的网站带有user-agent反爬的网站在发送请求之前必须要构建自己的请求头。 from urllib import request # 1.导包base_url = ‘http://www.xicidaili.com&#39; # 2.确定爬取资源headers = { # 3.构造请求头与请求 ‘User-Agent’: ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36’}req = request.Request(url=base_url, headers=headers)html = request.urlopen(req) # 4.发送请求with open(‘./xici.html’,’w’,encodeing=’utf-8’) as f: # 5.接受并存储信息 f.write(html)1234### 案例4：以上都是get请求 接下来做百度翻译(post请求)先通过抓包工具F12 newwork分析，找到翻译时发送的请求，因为是异步请求又是post请求，所以还要找到传递的参数。直接上代码： from urllib import request,parseimport ssl,jsonssl._create_default_https_context = ssl._create_unverified_context 确定爬取地址base_url = ‘https://fanyi.baidu.com/sug&#39;def fanyi(msg): dataform = { # 构造数据 ‘kw’: msg } newdataform = parse.urlencode(dataform) response = request.urlopen(url=base_url, data=bytes(newdataform, encoding=’utf-8’)) # 发送请求 res = response.read().decode(‘utf-8’) # 接受返回的数据 newres = json.loads(res) # print(json.loads(res), type(json.loads(res))) str = &apos;&apos; for item in newres[&apos;data&apos;]: str += item[&apos;v&apos;] + &apos;\n&apos; print(str) print(json.dumps(newres, indent=4, ensure_ascii=False)) # 将字典类型转换成字符串if name == “main“: while True: msg = input(‘请输入要翻译的单词：’) if msg == ‘q’: # 按q退出 break fanyi(msg)12注意：如果发送请求时出现如下错误： urllib.error.URLError: 1这是因为ssl 验证的错误，可以将下面代码粘贴，解决不进行验证： ssl._create_default_https_context = ssl._create_unverified_context` 练习：爬取百度贴吧，根据用户输入的贴吧名称，页码范围来爬取指定贴吧指定页数范围。爬取豆瓣电影的数据，这个是豆瓣电影的api:https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信之——socket套接字]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E2%80%94%E2%80%94socket%E5%A5%97%E6%8E%A5%E5%AD%97%2F</url>
    <content type="text"><![CDATA[什么是Socketsocket(简称 套接字)是一个网络通信的端点，它能实现不同主机间的进程通信，我们网络上各种各样大多数都是基于Socket来完成的通讯。 网络中进程之间如何通讯呢？首要解决的问题是如何确定你要和对方电脑上哪个进程进行通讯，这主要是利用协议，IP地址，端口标识网络的进程，然后通过这些标识进行通讯。 socket——UDP网络通讯使用socket创建UDP通讯的过程很简单，如下图：根据上图我们可以总结创建服务端和客户端的步骤，使用代码分别实现服务端和客户端：123456789101112131415161718服务端：1.创建套接字对象2.绑定ip地址和端口号3.接受消息4.返回消息5.关闭套接字import socket# 创建套接字udp_s = socket.socked(socket.AF_INET,socket.SOCK_DGRAM)# 绑定ip地址udp_s.bind((&apos;&apos;,8080))# 接受消息data,addr = udp_s.recvfrom(1024)print(data)# 关闭套接字udp_s.close() 123456789101112客户端：1.创建套接字对象2.发送消息3.关闭套接字对象import socekd# 创建套接字对象udp_c = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)# 发送消息udp_c.sendto(&apos;hello&apos;.encode(&apos;utf-8&apos;),(&apos;192.168.1.15&apos;,8080))# 关闭套接字udp_c.close() Socket–TCP网络通讯TCP通讯过程如下图：从图上可以看出，创建服务端通信需要经过：1234567891011121314151617181920212223242526272829301.创建套接字对象2.绑定ip地址和端口号3.监听4.接受消息5.返回消息6.关闭套接字import sockettcp_s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)tcp_s.bind((&apos;&apos;,8080))tcp_s.listen()s,addr = tcp_s.accept()data = s.recv(1024)print(data.decode(&apos;utf-8&apos;))s.send(&apos;hello&apos;.encode(&apos;utf-8))s.close()tcp_s.close()``` 创建客户端通信需要经过：``` 1.创建套接字对象2.创建连接3.发送消息4.关闭套接字对象import sockettcp_c = socket.socket(socket.AF_INET,socket.SOCK_STRAM)tcp_c.connect((&apos;192.168.1.15&apos;,8080))tcp_c.send(&apos;hello&apos;.encode(&apos;utf-8&apos;))tcp_c.close()]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>网络通信学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议之——UDP和TCP]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E2%80%94%E2%80%94UDP%E5%92%8CTCP%2F</url>
    <content type="text"><![CDATA[UDP协议和TCP协议UDP协议UDP：用户数据报协议，不可靠性，只是把应用程序传给IP层数据报送出去，但是不能保证他们是否能到达目的地，传输数据报前不用再客户端和服务器之间建立连接，并且没有超时重发机制，所以传输速度快。特点：安全性差，传输速度快，无序，大小有限制64kb。 TCP协议我们知道，在通讯之前，一定要先建立相关链接，才能发送数据。 下面是tcp建立连接 三次握手的概述：其中：ACK：确认标志，SYN：同步标志第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。完成三次握手，主机A与主机B开始传送数据。特点：安全性高，稳定性好，有序；速度相对较慢。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F04%2F06%2Fgit01%2F</url>
    <content type="text"><![CDATA[一张git版本控制常用命令图送给你Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。下面是一张关于git版本控制的常用命令表： 参考自：Git教程|菜鸟教程]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象——super()]]></title>
    <url>%2F2019%2F04%2F05%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94super%2F</url>
    <content type="text"><![CDATA[Python OOP中关于super()的描述在Python OOP实际应用中，有一个函数super()，通过这个函数可以允许继承父类的子类访问该父类中的方法。super()会在该子类当中单独返回一个父类的临时对象，然后允许你在该子类中调用该父类所拥有的方法。通常使用super()这个函数调用父类当中所构建的方法，这可以使你无需在子类中重写这些方法，并允许你使用最少的代码更改来替换父类。在对Python super()有了一个大致的认识后，下面说一说Python中关于各种继承（单继承、多继承）对super()的简单应用等。 Python单继承之super()首先来定义两个类：Rectangle、Square，通过这两个类来说明继承关系。定义类如下：12345678910111213141516171819202122232425262728293031class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, height): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.length def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return self.length &lt;&lt; 2square = Square(4) # 实例化正方形类print(square.area())rectangle = Rectangle(2, 4) # 实例化矩形类print(rectangle.area()) 通过此示例发现，这两个类是两个相互有关联的形状类：正方形是一种特殊的矩形， 但以上的代码似乎并没有展示出这种关系，因此这两个类具有重复的代码。找出了相关性，我们就可以通过这种相关性类实现继承的关系，通过继承减少代码的量的编写：1234567891011121314151617181920212223class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)square = Square(4) # 实例化正方形类print(square.area())rectangle = Rectangle(2, 4) # 实例化矩形类print(rectangle.area()) 在这里，我们使用了super()来调用Rectangle类的init ()，允许我们在Square类中使用它而不重复代码。 如下所示，核心功能在进行更改后仍然存在。因为Square和Rectangle . init ()方法非常相似，所以你可以使用super()从Square的方法中调用超类的. init ()方法（Rectangle . init ()）。 这里设置了.length和.width属性，即使您只需要为Square构造函数提供单个长度参数。当你运行它时，即使你的Square类没有显式地实现它，对.area()的调用将使用超类中的.area()方法并打印16. Square类从Rectangle继承.area() 方法。 super()在单继承中能为你做什么呢？与其他面向对象语言一样，它允许您在子类中调用父类的方法。这种情况的主要用例是扩展继承方法的功能。在下面的示例中，您将创建一个继承自Square的类Cube，并扩展.area()的功能（通过Square继承自Rectangle类）以计算Cube实例的表面积和体积：12345678910111213141516171819202122232425262728293031323334class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): &apos;&apos;&apos;计算表面积&apos;&apos;&apos; face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.length 这时，让我们看一下边长为3的立方体的表面积和体积：123cube = Cube(3)print(cube.surface_area()) # 54print(cube.volume()) # 27 从上面可以看出，我们为Cube立方体类实现了两个方法：.surface_area()和.volume()。这两个计算都依赖于计算单个面的面积，因此您不必重新实现面积计算，而是使用super()来扩展面积计算。另外请注意，Cube类定义没有. init ()。因为Cube继承自Square，而. init ()并没有为Cube做任何不同的事情，所以你可以跳过定义它，并且将自动调用超类（Square）的. init ()。super()将委托对象返回给父类，因此您可以直接调用它所需的方法：super().area()。这不仅使我们不必重写面积计算方法，而且还允许我们在一个位置更改内部.area()逻辑。当你有一些继承自一个父类的子类时，这尤其有用。介绍了上面这些示例，下面我们探索一下super()它的机制。 super()机制我们发现，上面一系列的示例是在没有任何参数的情况下调用super()的，然而super()也可以使用两个参数：第一个是子类，第二个参数是作为该子类实例的对象。首先，让我们看两个示例，通过使用已有的类来展示操作第一个变量可以做什么：123456789101112131415161718192021class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super(Square, self).__init__(length, length) 在Python 3当中，super(Square，self)调用等同于无参数的super()调用。 第一个参数指的是子类Square，而第二个参数指的是Square对象，在这种情况下，它是self。 我们也可以使用其他类调用super()：1234567891011class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): &apos;&apos;&apos;计算表面积&apos;&apos;&apos; face_area = super(Square, self).area() return face_area * 6 def volume(self): face_area = super(Square, self).area() return face_area * self.length 在此示例中，您将Square设置为super()的子类参数，而不是Cube。 这导致super()开始在实例层次结构中的Square上方的一个级别搜索匹配方法（在本例中为.area()方法），在本例中为Rectangle类。在此特定示例中，行为不会更改。 但想象一下Square还实现了一个你想要确保Cube不使用的.area()方法。 以这种方式调用super()可以让你这样做。第二个参数怎么样？请记住，这是一个对象，它是用作第一个参数的类的实例。例如，isinstance(Cube，Square)必须返回True。通过包含实例化对象，super()返回一个绑定方法：绑定到对象的方法，用来为方法提供对象的上下文，例如任何实例属性。如果未包含此参数，则返回的方法只是一个函数，与对象的上下文无关。（注意：super()不返回方法。它返回一个代理对象。它将调用正确的类方法，而不需要另外创建一个对象。） Python多继承之super()了解了单继承的super()和它的一些示例，下面，我们将开始了解多继承的一些概述和一些示例，这些示例将演示多继承如何工作以及super()如何启用该功能。 多继承概述Python支持多继承，其中子类可以从多个不必继承的超类（也称为兄弟类）继承。为了更好地说明多继承的实际应用，下面将展示如何通过三角形和正方形构建一个右金字塔（带有方形底座的金字塔）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height): self.base = base self.height = height def area(self): return self.base * self.height * 0.5class RightPyramid(Triangle, Square): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base # 倾斜高度：从物体底部中心（如金字塔）到其面部到该物体顶部的高度 self.slant_height = slant_height def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area 此示例原来的基础上又声明了一个Triangle类和一个继承Square和Triangle的RightPyramid类。您将看到另一个使用super()的.area()方法，就像在单继承中一样，目的是用到在Rectangle类中一直定义的.perimeter()和.area()方法。但问题是两个超类（Triangle和Square）都定义了一个.area()。花一点时间思考在RightPyramid上调用.area()时会发生什么，然后尝试调用它，如下所示：12345678910pyramid = RightPyramid(2, 4)print(pyramid.area())# Traceback (most recent call last):# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 103, in &lt;module&gt;# print(pyramid.area())# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 99, in area# base_area = super().area()# File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 88, in area# return self.base * self.height * 0.5# AttributeError: &apos;RightPyramid&apos; object has no attribute &apos;height&apos; 您是否猜测Python会尝试调用Triangle.area()？ 这是因为所谓的方法解析顺序在起作用。注意：我们怎么注意到Triangle.area()被调用了，而不是像我们希望的那样，Square.area()？ 如果查看回溯的最后一行（在AttributeError之前），您将看到对特定代码行的引用：1return self.base * self.height * 0.5 您可以将几何类中的这个方法认为是三角形面积公式。 或者，你可能已经找到Triangle和Rectangle类定义，并在Triangle.area()中看到了相同的代码。 方法解析顺序mro方法解析顺序告诉Python如何搜索继承来的方法，当你使用super()时，这回排上很大的用场，因为mro会告诉Python将使用super()以及以什么样的顺序来进行调用的方法。每个类都会有一个.mro的魔术属性，它允许我们检查顺序：123print(RightPyramid.__mro__) # 打印结果：(&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;object&apos;&gt;) 这告诉我们首先在Rightpyramid中搜索方法，然后在Triangle中搜索，然后在Square中搜索，然后在Rectangle中搜索，然后，如果没有找到，则在对象中搜索。 这里的问题是解释器在Square和Rectangle之前在Triangle中搜索.area()，并且在Triangle中找到.area()时，Python会调用它而不是你想要的那个。 因为Triangle.area()期望有.height和.base属性，所以Python会抛出AttributeError。 幸运的是，您可以控制MRO的构建方式。 只需更改RightPyramid类的签名，即可按所需顺序进行搜索，方法将正确解析：123456789101112class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area 请注意，RightPyramid使用Square类中的. init ()进行部分初始化。 这允许.area()在对象上使用.length，如设计的那样。 现在，您可以构建金字塔类，检查MRO并计算表面积：123pyramid = RightPyramid(2, 4)print(pyramid.area()) # 20.0print(RightPyramid.__mro__) # (&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;object&apos;&gt;) 您可以看到MRO现在是您所期望的，并且您也可以检查金字塔的表面积，这要归功于.area()和.perimeter()。 不过，这里仍然存在问题。为了简单起见，我在这个例子中故意设置了一些错误：第一个，可以说最重要的是，我有两个具有相同方法名称和签名的独立类。 这会导致方法解析问题，因为将调用MRO列表中遇到的.area()的第一个实例。 当您使用具有多重继承的super()时，必须设计您的类以进行协作。其中一点是确保您的方法是唯一的，以便通过签名确保方法是唯一的 - 无论是使用方法名称还是方法参数，在MRO中正确解析它们。 在这种情况下，为了避免对代码进行彻底检查，可以将Triangle类的.area()方法重命名为.tri_area()。这样，area方法可以继续使用类属性而不是使用外部参数：12345678910class Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height): self.base = base self.height = height super().__init__() def tri_area(self): return self.base * self.height * 0.5 让我们继续在RightPyramid类中使用它：12345678910111213141516class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height): self.base = base self.slant_height = slant_height super().__init__(self.base) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area 这里的下一个问题是代码没有像Square对象那样的委托的Triangle对象，所以调用.area_2()会给我们一个AttributeError，因为.base和.height没有任何值。 你需要做两件事来解决这个问题： 1.使用super()调用的所有方法都需要调用其超类的该方法版本。 这意味着您需要将super(). init ()添加到Triangle和Rectangle的. init ()方法中。 2.重新设计所有. init ()调用以获取关键字字典。 请参阅下面的完整代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length, **kwargs): self.width = width self.length = length super().__init__(**kwargs) def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.width def perimeter(self): &apos;&apos;&apos;计算周长&apos;&apos;&apos; return (self.width + self.length) &lt;&lt; 1class Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length, **kwargs): super().__init__(length=length, width=length, **kwargs)class Cube(Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def surface_area(self): face_area = super().area() return face_area * 6 def volume(self): face_area = super().area() return face_area * self.lengthclass Triangle(): &apos;&apos;&apos;三角形类&apos;&apos;&apos; def __init__(self, base, height, **kwargs): self.base = base self.height = height super().__init__(**kwargs) def tri_area(self): return self.base * self.height * 0.5class RightPyramid(Square, Triangle): &apos;&apos;&apos;右金字塔类&apos;&apos;&apos; def __init__(self, base, slant_height, **kwargs): self.base = base self.slant_height = slant_height kwargs[&quot;height&quot;] = slant_height kwargs[&quot;length&quot;] = base super().__init__(base=base, **kwargs) def area(self): base_area = super().area() perimeter = super().perimeter() return perimeter * self.slant_height * 0.5 + base_area def area_2(self): base_area = super().area() triangle_area = super().tri_area() return triangle_area * 4 + base_area 此代码中存在许多重要差异： 1.kwargs在某些地方被修改（例如RightPyramid . init ()): 这将允许这些对象的用户仅使用对该特定对象有意义的参数来实例化它们。 2.在kwargs之前设置命名参数：你可以在RightPyramid . init ()中看到这个。 这具有从kwargs字典中去除特定键的简洁效果，因此当它在MRO中最终进行到object时，**kwargs为空。现在，当您使用这些更新的类时，您有：123pyramid = RightPyramid(base=2, slant_height=4)print(pyramid.area()) # 20print(pyramid.area_2()) # 20.0 起作用了！ 您已经使用super()成功追溯复杂的类层次结构，同时使用继承和组合来创建具有最少重新实现的新类。 多重继承替代方案如您所见，多重继承可能很有用，但也会导致非常复杂的情况和难以阅读的代码。 拥有整齐地从多个其他对象继承所有东西的对象也很少见。 如果您发现自己开始使用多重继承和复杂的类层次结构，那么值得问问自己是否可以通过使用组合而不是继承来实现更清晰，更易于理解的代码。 通过组合，您可以从一个称为mixin的专用简单类中为您的类添加非常特定的功能。 由于本文主要关注继承，因此我不会详细介绍组合以及如何在Python中使用它，但这里有一个使用VolumeMixin为我们的3D对象提供特定功能的简短示例 - 在这种情况下，是一个体积计算：1234567891011121314151617181920212223242526272829303132333435class Rectangle(): &apos;&apos;&apos;矩形类&apos;&apos;&apos; def __init__(self, width, length): self.width = width self.length = length def area(self): &apos;&apos;&apos;计算面积&apos;&apos;&apos; return self.length * self.widthclass Square(Rectangle): &apos;&apos;&apos;正方形类&apos;&apos;&apos; def __init__(self, length): super().__init__(length, length)class VolumeMixin(): def volume(self): return self.area() * self.heightclass Cube(VolumeMixin, Square): &apos;&apos;&apos;立方体类&apos;&apos;&apos; def __init__(self, length): super().__init__(length) self.height = length def surface_area(self): face_area = super().area() return face_area * 6 def face_area(self): return super().area() 在这个例子中，代码被重新设计为包含一个名为VolumeMixin的mixin。 然后，Cube使用mixin并使Cube能够计算其体积，如下所示：123cube = Cube(2)print(cube.surface_area()) # 24print(cube.volume()) # 8 这个mixin可以在任何需要计算体积的类中以相同的方式使用，并且公式area*height返回正确的结果。 有关Python中面向对象编程和使用super()的更多信息，请查看以下资源： 官方的super()文档 由Raymond Hettinger写的Python的super()真的超赞 Python中面向对象的编程3 参考自：使用Python Super()为类提供继承支持 译者：javylee英文原文]]></content>
      <categories>
        <category>Python面向对象</category>
      </categories>
      <tags>
        <tag>Python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块——hashlib]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94hashlib%2F</url>
    <content type="text"><![CDATA[Python的hashlib提供了常见的摘要算法，如MD5，SHA1，SHA224，SHA256，SHA384，SHA512等等,用于加密数据。什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值： MD51234import hashlibmd5 = hashlib.md5(b&apos;how to use md5 in python hashlib?&apos;)password_md5 = md5.hexdigest()print(password_md5) # d26a53750bc40b38b65a520292f69306 如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：12345import hashlibmd5 = hashlib.md5()md5.update(b&apos;how to use md5 in &apos;)md5.update(b&apos;python hashlib?&apos;)print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306 MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似： SHA1SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。12345import hashlibsha1 = hashlib.sha1()sha1.update(b&apos;how to use sha1 in &apos;)sha1.update(b&apos;python hashlib?&apos;)print(sha1.hexdigest()) # 2c76b57293ce30acef38d98f6046927161b46a44 摘要算法应用任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：12345name | password--------+----------michael | 123456bob | abc999alice | alice2008 如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：12345username | password---------+---------------------------------michael | e10adc3949ba59abbe56e057f20f883ebob | 878ef96e86145580c38c87f0410ad153alice | 99b1c2188db85afee403b1536010c2c9 考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：123&apos;e10adc3949ba59abbe56e057f20f883e&apos;: &apos;123456&apos;&apos;21218cca77804d2ba1922c33e0151105&apos;: &apos;888888&apos;&apos;5f4dcc3b5aa765d61d8327deb882cf99&apos;: &apos;password&apos; 这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：1hashlib.md5(&quot;salt&quot;.encode(&quot;utf8&quot;)) 经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块——sys]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94sys%2F</url>
    <content type="text"><![CDATA[sys模块sys模块是与python解释器交互的一个接口。下面是常用的的一些接口解释：12345sys.argv 命令行参数List，第一个元素是程序本身路径sys.exit(n) 退出程序，正常退出时exit(0),错误退出sys.exit(1)sys.version 获取Python解释程序的版本信息sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站流量术语]]></title>
    <url>%2F2019%2F04%2F04%2FHTTP%E5%AD%A6%E4%B9%A003%2F</url>
    <content type="text"><![CDATA[网站统计一般以数值较大的IP,PV统计，比较好看。 IPIP即Internet Protocol，这里是指独立ip数，不同的ip地址的计算机访问网站时被计算的总次数。独立ip数是网站流量的一个重要指标。一般相同ip地址的客户端访问网站页面一天内只会被计算一次。这里的ip指的是是固定的公网ip。 PVpv（Page View）即是页面浏览量，不管客户端是不是相同，也不管ip是否相同，用户只要访问网站页面就会被计算PV，一次计算一个PV。pv的度量方法就是客户端从浏览器发出一个web请求（request），服务器接收请求返回一个页面给客户端，这样就产生一个pv。页面刷新一下，就是一个PV。 UVUV即unique visitor，同一个客户端（pc或移动端）访问网站被计算为一个访客。一天内相同的客户端访问同一个网站只计一次uv，uv是以cookie等技术为统计依据，实际统计存在误差。一台计算机可能有多人使用，因此uv也不是最准确的。 并发数并发数指系统同时能处理的请求数量，也反应了系统的负载能力。 响应时间响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。 QPSQuery Per Second：每秒查询数服务器在一秒内处理了多少个请求，显然数字越大代表服务器的负载越高，处理能力越强。 12345Http相关术语pv、ip、uv 假设公司有一座大厦，大厦有100人，每个人有一台电脑和一部手机，上网都是通过nat转换出口，每个人点击网站2次（发2次请求）, 请问对应的pv,uv,ip分别是多少？PV：页面浏览量, 400 100人 2个设备 访问2次 =400数uv：独立的客户, 200 100人2个设备=200数ip：独立IP, 1个 同一个NAT出口，独立IP为1]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文、URI]]></title>
    <url>%2F2019%2F04%2F03%2FHTTP%E5%AD%A6%E4%B9%A002%2F</url>
    <content type="text"><![CDATA[什么是http报文？它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。 HTTP请求报文由请求行，请求头部，空行，请求报文主体几个部分组成，即：12345起始行： &lt;method&gt; &lt;request-URL&gt; &lt;version&gt;头部： &lt;headers&gt;主体： &lt;entity-body&gt; HTTP响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：123状态行响应头(Response Header)响应正文 URIuri中文叫“统一资源标识符”，是一个用于标识某一互联网资源名称的字符串，在世界范围内标识定位某一个唯一信息资源。还有一个概念叫做URL，那什么是URL？URL简称统一资源定位符。那URL的组成部分是由协议, 域名:端口, 路径和文件名。url主要用在各种www客户端和服务器程序上，url可以用一种统一的格式来描述各种信息资源，包括文件，服务器地址和目录等。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介、特点、版本、请求方法、状态码]]></title>
    <url>%2F2019%2F04%2F03%2FHTTP%E5%AD%A6%E4%B9%A001%2F</url>
    <content type="text"><![CDATA[## 一、Web服务基础用户访问网站的基本流程： 1、双击浏览器，输入目标网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在目标域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用2、如果本地dns缓存和hosts文件都没有域名解析记录，系统就会把访问的网址解析请求发送给客户端设置的DNS服务器去解析，也叫做Local DNS，如果LDNS服务器的本地缓存有对应的解析记录就会直接返回给客户端IP地址，如果没有LDNS就会继续请求其他的DNS服务器3、LDNS继续从DNS系统的”.”(根)开始请求目标域名的解析，并且根据每个层级的DNS服务器系统进行系列的查找，最终在DNS网络上找到目标域名对应的授权DNS服务器。这个授权DNS服务器就是企业（个人）购买域名时用于管理域名解析的服务器，服务器上有对应的域名（IP）解析。4、此时授权的DNS服务器就会把目标对应的IP解析记录，例如（1.1.1.1）发送给LDNS5、此时LDNS会把解析记录发给浏览器，并且缓存域名和IP的解析记录，便于下一次更快的返回请求6、浏览器获得ip，请求对应的服务器，网站服务器接收到客户端的请求开始响应处理，将内容返回给浏览器。 二、HTTP协议全称是HyperText Tansfer Protocol,中文叫超文本传输协议，是互联网最常见的协议。 Http最重要的是www(World Wide Web)服务，也叫web服务器，中文叫“万维网”。 web服务端口默认是80，另外一个加密的www服务应用https默认端口是443，主要用于支付，网银相关业务。 三、HTTP协议的特点 1.HTTP协议是无状态的 就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。 2.多次HTTP请求 在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。 3.基于TCP协议 HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。 四、版本http协议诞生以来有若干个版本，主要是http/1.0 http/1.1 http/1.0规定浏览器和服务器只能保持短暂的连接，浏览器的每次请求都需要和服务器建立一个TCP连接，服务器完成请求后即断开TCP连接，服务器不跟踪每个链接，也不记录请求 http/1.1是对HTTP的缺陷进行重点修复，从可扩展性，缓存，带宽优化，持久连接，host头，错误通知等访问改进。 http/1.1支持长连接，增加了更多的请求头和响应头信息，例如配置请求头的Connection的值为keep-alive，表示请求结果返回后保持连接 五、Http请求方法在HTTP通信中，每个请求报文都包含一个方法，以告诉web服务器端需要执行哪些操作，这些动作被称为HTTP的请求方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 六、HTTP状态码HTTP状态码表示web服务器响应http请求状态的数字代码。 常见状态码以及作用： 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 七、HTTP状态码的命令查看$ curl -I www.oldboyedu.com 参考自：https://pythonav.com/wiki/detail/3/34/和https://www.cnblogs.com/wxisme/p/6212797.html]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx多个虚拟主机]]></title>
    <url>%2F2019%2F04%2F03%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9303%2F</url>
    <content type="text"><![CDATA[## Nginx多个虚拟主机想象一下，如果网站部署者在部署网站时，每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。于是就有了解决这种局面的办法：虚拟主机。虚拟主机就是将一台服务器分割成了多个“虚拟服务器”，每个站点可以使用各自的硬盘空间，由于节省资源、省钱，许多网站使用虚拟主机来部署网站。虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。 虚拟主机类型12345678- 基于域名的虚拟主机通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。- 基于端口的虚拟主机通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000- 基于IP的虚拟主机通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果。 修改nginx.conf12345678910111213141516171819202122232425262728293031323334egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf#配置文件内容如下worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; sendfile on; keepalive_timeout 65; #虚拟主机1 server &#123; listen 80; server_name www.pyyuc.cn; location /&#123; root html/pyyuc; index index.html index.htm; &#125;&#125; #虚拟主机2 server &#123; listen 80; server_name www.pythonav.cn; location /&#123; root html/pythonav; index index.html index.htm; &#125;&#125; &#125; 1234[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn&lt;meta charset=utf8&gt;我是pyyuc站点 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx目录、部署站点]]></title>
    <url>%2F2019%2F04%2F03%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9302%2F</url>
    <content type="text"><![CDATA[一、nginx软件目录12[root@yc-virtual-machine /opt/nginx1-12 11:44:02]#lsclient_body_temp conf fastcgi_temp html logs proxy_temp sbin scgi_temp static uwsgi_temp conf 存放nginx所有配置文件的目录,主要nginx.conf html 存放nginx默认站点的目录，如index.html、error.html等 logs 存放nginx默认日志的目录，如error.log access.log sbin 存放nginx主命令的目录,sbin/nginx Nginx主配置文件/etc/nginx/nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号{}来表示开始与结束。123456CoreModule核心模块user www; #Nginx进程所使用的用户worker_processes 1; #Nginx运行的work进程数量(建议与CPU数量一致或auto)error_log /log/nginx/error.log #Nginx错误日志存放路径pid /var/run/nginx.pid #Nginx服务运行后产生的pid进程号 123456events事件模块events &#123; worker_connections //每个worker进程支持的最大连接数 use epool; //事件驱动模型, epoll默认&#125; 12345678910111213141516171819202122232425http内核模块// 公共的配置定义在http&#123;&#125;http &#123; //http层开始... // 使用Server配置网站, 每个Server&#123;&#125;代表一个网站(简称虚拟主机) &apos;server&apos; &#123; listen 80; // 监听端口, 默认80 server_name localhost; // 提供服务的域名或主机名 access_log host.access.log // 访问日志 // 控制网站访问路径 &apos;location&apos; / &#123; root /usr/share/nginx/html; // 存放网站代码路径 index index.html index.htm; // 服务器返回的默认页面文件 &#125; // 指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton error_page 500 502 503 504 /50x.html; &#125; ... //第二个虚拟主机配置 &apos;server&apos; &#123; ... &#125; include /etc/nginx/conf.d/*.conf; // 包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件&#125; // http层结束 二、部署nginx站点nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到1234location /&#123; root html; #这里是默认的站点html文件夹，也就是 /opt/nginx1-12/html/文件夹下的内容 index index.html index.htm; #站点首页文件名是index.html &#125; 如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可12[root@yc-virtual-machine /tmp 11:34:52]#ls /opt/nginx1-12/html/index.html jssts.jpeg lhy.mp4 man.jpg wget-log 至此，只需要通过域名/资源，即可访问1http://www.pyyuc.cn/index.html 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx简介、安装]]></title>
    <url>%2F2019%2F04%2F02%2Fnginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9301%2F</url>
    <content type="text"><![CDATA[一、nginx出世2004年10月4日，为俄罗斯知名门户站点而开发的Web服务程序 Nginx 横空出世。Nginx程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市场，但Nginx最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。 二、nginx介绍 nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。 nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。 nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。 安装更为简单，方便，灵活。 支持高并发，能支持几万并发连接 资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M 可以做http反向代理和负载均衡 支持异步网络i/o事件模型epoll下面介绍nginx的安装与配置 三、安装配置nginx安装nginx前的依赖环境解决123456789101112131415#执行第一条语句即可yum install gcc patch libffi-devel python-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y#依赖简单介绍一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 编译安装nginx12345678910111213141.下载源码包wget -c https://nginx.org/download/nginx-1.12.0.tar.gz2.解压缩源码tar -zxvf nginx-1.12.0.tar.gz3.配置，编译安装 开启nginx状态监测功能./configure --prefix=/opt/nginx112/ make &amp;&amp; make install 4.启动nginx，进入sbin目录,找到nginx启动命令cd sbin./nginx #启动./nginx -s stop #关闭./nginx -s reload #重新加载5.修改PATHPATH=$PATH:/opt/nginx112/ 参考自：https://pythonav.com/wiki/detail/3/34/]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2018%2F11%2F19%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、Linux与Windows的区别体现在目录的结构和安全性上，Linux所有的命令是以文件形式存储的，在Linux系统当中一切皆为文件（常用的比如：普通文件、目录文件、链接文件、设备文件等）。二、目录含义/bin 存放普通用户的命令文件/boot 存放系统启动文件/cdrom 存放读取光盘/dev 存放设备相关文件/etc 存放配置文件/home 家目录/lib 库文件相关/lib64 64位库文件/lost+found 系统异常产生错误时，丢失文件放在这里/media 媒体文件/mnt 挂载目录/opt 安装软件时的默认目录/proc 内存中相关数据文件/root root用户登录的家目录/run 系统运行的时候用到的文件/sbin 超级管理员运行的文件/srv 服务启动之后需要访问的数据目录/sys 系统文件/tmp 临时文件/usr 应用程序存放目录/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件 三、相关命令查看命令（目录结构、路径）：. 当前路径.. 上一级路径cd .. 回到上一级cd 切换到家目录cd ~ 切换到家目录cd - 回到上一个你操作的那一个目录pwd 查看当前所在的目录是哪里ls 查看当前文件夹里面有什么 .bash_history 但凡是点开头的文件，都是隐藏文件 -a 所有文件（包括隐藏文件） -l 以列表的形式呈现 -h 可以让文件大小带上单位ll 相当于ls -alman 是帮助命令，比如：man ls或man cpnano 内置自带的文本编辑器（编辑文件用的）cat 查看文件内容more 对于内容较多的情况下用more支持分页，空格下一页head 加上-2是查看前几条tail 加上-2是查看后几条dmesg 查看系统接入设备信息top 查看运行状态sudo service network-manager restart 网络有线未托管sudo apt-get install vim操作命令（新建、复制粘贴剪切、删除）：mkdir 要创建的文件夹名字touch 要创建的文件名ln -s 创建软链接，ln -s 指定你想要创建的连接 放到哪个目录下面，ln -s 需要使用绝对路径的方式来创建。mv /路径/文件夹或文件 新名称 功能：既可以剪切也可以改名cp 路径 路径（从哪里~到哪里去）cp 默认只能够复制文件cp -r 可以复制文件夹cp -a 可以复制权限和所有属性rm -rf 指定文件夹或者文件名称 功能：用于删除文件或者目录查找命令（找文件、文件内容）：find 搜索文件的命令find 查找位置 -name 文件名find / -iname index.phpgrep 搜索文件里面符合条件的内容grep “字符串” 文件名grep -i “root”grep -v “root”挂载操作命令：sudo fdisk -l 查看当前系统有哪些挂载设备sudo mount 找到的设备路径 /mnt/cdrom 挂载sudo umount /mnt/cdrom(umount + 挂载的目录) 取消挂载 四、权限结构在Linux中，无论文件夹还是文件都是有权限的，通过在终端键入ls -l命令行可以看到每一行开始都有类似drwxrwxr-x的一串字符码，当中就包含有权限的标识。其中：第一位表示类型，即说明是文件夹(d)、文件(-)以及链接(l)中的哪一类型；后面的9位，每三位划分为一组作为权限位，从前往后这三个权限位分别标识所属主、所属组、其他用户的权限。指定类型(dl-) 权限位1(rwx) 权限位2(rwx) 权限位3(rwx)，其中r=&gt;read w=&gt;write x=&gt;可执行，r =&gt; 4, w =&gt; 2, x =&gt; 1。d rwx rwx r-x文件类型-所属主 所属组 其他 d rwx rwx rwx位数1,2,3 代表当前文件或者文件夹的所有者的权限设定:(所有者的权限 u,user) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行位数4,5,6 代表当前文件或者文件夹的所属组的权限设定:(所属组的权限 g ,group) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行位数7,8,9 代表其他用户对当前文件或者文件夹的的权限设定:(其他人的权限 o,other) 1: r 或者 - r表示可以读取 - 表示不可以读取 2: w 或者 - w表示可以写入 - 表示不可以写入 3: x 或者 - x表示可以执行 - 表示不可以执行更改权限rwx的任意组合共 8 种 情况：rwx =&gt; 7rw- =&gt; 6r-x =&gt; 5r– =&gt; 4-wx =&gt; 3-w- =&gt; 2–x =&gt; 1— =&gt; 0其中r =&gt; 4, w =&gt; 2, x =&gt; 1。例如：根目录下默认的文件夹权限为755（rwx r-x r-x） ，根目录下默认的文件权限为644（rw- r– r–），所有权限为777（rwx rwx rwx）关于权限更改的各种写法chmod 755 1.txtchmod -R 777 ceshi100(chmod -R 777 文件夹) # 递归更改这个文件夹里面的所有文件权限chmod u+r,g-w,o+x 1.txtchmod u=rwx 1.txt其中：u代表所有者 加一个r权限 (user)g代表所属组 减一个w权限 (group)o代表其他 加一个执行权限 (other)=&gt;对于目录来讲r 是否呈现里面的文件w 是否可以在里面创建文件或文件夹x cd 切不进来 不能访问这个目录=&gt;对于文件来讲r 可以看到文件内容w 可以更改删除文件及内容x 是否可以执行这个文件 ./abc.sh (*扩展)sudo useradd a01 添加新用户账号sudo passwd a01 为新用户设置密码sudo su a01 切换用户账号exit 退出当前用户 http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础总结]]></title>
    <url>%2F2018%2F11%2F17%2FPython%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、注释1、 注释的排错性 先注释一部分代码，然后执行另外一部分代码，查看报错，用于调试。2、注释的注意点 多行注释的嵌套： 如果外面是三个单引号，则里面要用三个双引号；如果外面是三个双引号，则里面要用三个单引号。二、变量1、概念：可以改变的量，具体是指内存中的一段存储空间。 house305 = “张三” print(house305) house305 = “李四” print(house305)2、变量的三种声明方式： 方式一 a = 1 b = 2 方式二 a, b = 1, 2 方式三 a = b = 3 (注意：这种方式的id(a) == id(b)) 3、变量的命名规范：字母数字下划线，首字母不能为数字。严格区分大小写，且不能使用关键字。变量命名有意义，且不能使用中文哦。import keywordprint(keyword.kwlist) # [‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]4、变量的交换a = 3b = 10a, b = b, aprint(a, b) # 10 3 三、Python的六大数据类型分为：Number型、容器类型（字符串型、列表型、元组型、集合型、字典型）。(1)Number数字类型(int float bool complex) ①Number类型之int 整型(正整数 0 负整数) intvar = 37 print(intvar) # type() 查看一个值的数据类型 res = type(intvar) print(res) #&lt;class &apos;int&apos;&gt; # id() 查看一个变量所指向值的地址 res = id(intvar) print(res) #10915520 # 二进制整型 intvar = 0b1010101 # 八进制整型 intvar = 0o127 # 十六进制整型 intvar = 0xFF # 变量声明的第三种方式 特点 a = b = 89 res1 = id(a) res2 = id(b) print(res1) print(res2) ②Number类型之float 浮点型 （小数：1普通小数 2科学计数法表示的小数。例:a = 3e-5 #3e-05 ） (1)表示方式一 floatvar = 3.14 (2)表示方式二 floatvar = 3.14e-2 # 小数点向左移动2位 floatvar = 3.14e04 # 小数点向右移动4位 ③Number类型之bool 布尔型 （True 真的 False 假的） boolvar = True boolvar = False ④Number类型之complex 复数类型（实数+虚数 组成） ‘&apos;&apos; 如果有一个数，它的平方是-1，那么这个数就是j (科学家认为有，表达一个高精度的类型) &apos;&apos;&apos; (1) 表达方式一 complexvar = 3 + 4j complexvar = 4j (2)表达方式二 &apos;&apos;&apos; var1 = complex(实数,虚数) 通过complex强制转换成复数类型 &apos;&apos;&apos; complexvar = complex(3, 5) （2）String字符串型特征：可获取，不可修改的有序容器类型数据。 # error strvar=&quot;这是真的字符串&quot; strvar[-3] = &quot;假&quot; print(strvar) 字符串有三种类型：通过单引号、双引号、三引号（可以支持跨行,不需要对单双引号进行转义）引起来的字符串。转义字符： 语法: \ + 字符 (1)将无意义的字符变得有意义 (2)将有意义的字符变得无意义 例如： \n 或者 \r\n : 代表换行 \t : 代表一个tab缩进(水平制表符) \r : 把\r后面的字符提到行首 strvar = “处处\r蚊子咬” print(strvar)元字符串：r+字符串：作用在于让转义字符失效，原型化输出 strvar = r’夜来\n大狗熊’ print(strvar) strvar = r”夜来\n大狗熊” print(strvar) strvar = r’’’夜来\n大狗熊’’’ print(strvar) strvar = r”””夜来\n大狗\r熊\t””” print(strvar)（3）List列表类型特征：可获取，可修改de有序容器类型数据。定义空列表： listvar = [] print(listvar)列表值的获取： listvar = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’] res = listvar[1] res = listvar[len(listvar) - 1]列表的修改： listvar = [‘a’, 14, 3,14, True, 4 + 3j] listvar[1] = “15”（4）Tuple元组类型特征：可获取，不可修改的有序的容器类型数据定义空元组： tuplevar = ()tuple类型的获取： tuplevar = (‘a’, ‘c’, ‘b’, ‘s’, 15 - 9j, False) res = tuplevar[-3]tuple类型不支持修改 # error tuplevar[0] = 1234 print(tuplevar) (5)Set集合类型特征：自动去重，无序的容器类型数据。作用：集合类型是用来做交集、差集、并集、补集操作的。注意点：无法通过索引来获取其中的数据。 setvar = {True, “你好”, 34, 9.2, 3 + 4j} print(setvar) print(setvar[1]) # error无法修改集合当中的值 setvar[0] = “999” # error print(setvar)单独定义一个{} 它代表的不是集合 而是字典 var = {} # 空字典 print(type(var)) #dict var = set() # 空集合 print(type(var))(6)Dict字典类型特征：键值对存储的，无序容器类型数据。dictvar = {‘top’: ‘程咬金’, ‘middle’: ‘貂蝉’, ‘bottm’: ‘鲁班七号’, ‘support’: ‘蔡文姬’, ‘jungle’: ‘韩信’}字典的获取：通过键获取值 res = dictvar[‘jungle’] print(res)字典的修改 dictvar[‘middle’] = ‘小乔’ print(dictvar) 四、类型转换–&gt;自动类型转换当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高:bool、int、float、complex。–&gt;强制类型转换Number类型强制转换通过int()、float()、complex()可以将整型、浮点型、布尔型以及纯数字字符串强转为对应的类型数据，而通过bool()则可以将Number类型数据和容器类型数据强转为bool类型数据。（扩展：布尔类型为假的时候，一共有10种情况：0, 0.0, False, 0j, ‘’, [], (), {}, set(), None）容器类型强制转换通过str()可以将Number类型和容器类型强制转为String型。通过list()可以将字符串、列表、元组、集合、字典类型强制转换为List类型，把字典强转成列表,只要其中的键,忽略其中的值。通过tuple()可以将容器类型数据强转为tuple类型数据，把字典强转成列表,只要其中的键,忽略其中的值。通过set()可以将容器类型数据强制转换为集合类型数据，把字典强转成集合,只要其中的键,忽略其中的值。dict()使用 二级列表 或 二级元组 (二级集合语法上不错,但是无序,不建议使用)‘’’强转成字典的条件：需要等长的二级容器’’’ 方式一var1 = [(“a”: 1), (“b”, 2)]var2 = [[‘a’: 3], [‘b’: 4]]var3 = [(‘a’: 5), [‘b’: 6]] var4 = [{‘a’: 7}, {‘b’: 8}]res = print(var4)print(res, type(res)) 方式二var1 = ((‘a’, 1), (‘b’, 2))var2 = ([‘a’, 3], [‘b’, 4])var3 = ((‘a’, 5), [‘b’, 6]) var4 = [{‘a’,7},{‘b’,8}] 切记不要使用res = dict(var4)print(res) 方式三var = {(‘a’, 1), (‘b’, 2)}res = dict(var)print(res) 五、以下数据类型存储规律仅对当前linux 64位的python3.x版本负责–&gt;Number 部分1.对于整型而言，-5~正无穷范围内的相同值 id一致2.对于浮点数而言，非负数范围内的相同值 id一致3.布尔值而言,值相同情况下，id一致4.复数的id标识都不相同(在 实数+虚数 这样的结构中)–&gt;容器类型部分5.字符串而言，字符串值相同情况下，id一致6.列表，元组，字典，集合无论什么情况 id标识都不同(但空元组的id标识一样) 六、Python运算符(1)算数运算符: + - / // % **(2)比较运算符: &gt; &lt; &gt;= &lt;= == !=(3)赋值运算符: = += -= = /= //= %= **=(4)成员运算符: in 和 not in (针对于容器型数据)(5)身份运算符: is 和 is not (检测两个数据在内存当中是否是同一个值)(6)逻辑运算符: and or notTrue and print(1)False and print(2) # 逻辑与短路True or print(3) # 逻辑或短路False or print(4)(7)位运算符: &amp; | ~ ^ &lt;&lt; &gt;&gt;按位非是对补码进行操作的，每一位按位取反，包括高位符号位(注意：原码和补码之间的互相转换，符号位不动)运算规律：公式：-(x + 1)例如：~19补码: 00000000 10011按位非: 11111111 01100给补码求原码:取反:1111111 10011加1 :1111111 10100 (原码)最终: -20~(-19)原码：11111111 10011给原码求补码：取反：11111111 01100加一：11111111 01101按位非运算： 00000000 10010最终：18运算符的优先级：一元运算符优先级 大于 二元运算符 一元运算符（~按位非 -负号） 例：~19只对一个数进行操作的运算符叫做一元运算符 二元运算符 例：1 + 2 对两个数 进行操作的运算符叫做二元运算符运算符优先级最低的是 赋值运算符当中的=运算符整体的优先顺序如下： 算数运算符 &gt; 位运算符 &gt; 比较运算符 &gt; 赋值运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 七、流程控制大致分为三种控制结构：顺序结构、分支结构、循环结构。分支结构分为：单项分支、双项分支、多项分支、巢状分支，通过if elif else关键字来构建。循环结构分为while / for… in…，通过循环结构可以减少代码的冗余，提高执行效率。for…in…循环多用于遍历容器类型数据，而while则不能遍历无序的容器类型数据。在遍历字典时，默认遍历字典的键。遍历等长的二级列表： listvar = [[‘a’, ‘b’, ‘c’], [‘d’, ‘e’, ‘f’], [‘g’, ‘h’, ‘j’]] for i, j, k in listvar: print(i, j, k)字符串的拼接：–&gt;正常拼接：通过“+”来拼接。 a = ‘1’ b = ‘2’ print(a + b)–&gt;跨行拼接：通过\来衔接不同的多行。 strvar = “123456”\ “7890”–&gt;重复拼接：通过字符 次数。 strvar = ‘love’ 10 pass用来占位 / break终止当前循环，只能用在循环当中 / continue跳过当前循环，后面的代码不执行，直接从下一次循环开始 八、函数关于函数(1)函数的含义:功能 (包裹一部分代码 实现某一个功能 达成某一个目的)(2)函数特点:可以反复调用,提高代码的复用性,提高开发效率,便于维护管理(3)函数基本格式 def func(): pass(4)驼峰命名法：（便于程序员更为方便的阅读代码）大驼峰命名法：MyCar（用在类的命名中）；小驼峰命名法：myCar（一般用在函数命名中）；普通情况下，一般用_来分割不同的词。 # 99乘法表的定义 def multiplication99_table(): for i in range(1, 10):; for j in range(1, i + 1): print(&quot;%d*%d=%2d &quot; % (i, j, i*j), end=&quot;&quot;) print() # 99乘法表的调用 multiplication99_table() 关于函数参数(1)函数参数概念及分类 函数参数:调用时需要传递的数据. 函数参数大类分为形参和实参: 形参: 在函数定义时，括号里面的参数，叫形参（形式参数） 实参: 在函数调用时，括号里面的参数，叫实参（实际参数） 形参与实参的关系:函数调用时,形参和实参个数需要一一对应 形参种类:普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数 实参种类:普通实参,关键字实参 默认形参和关键字实参区别：默认形参和关键字实参写法上一样，只不过默认形参在函数的定义处，关键字实参在函数的调用处。(2)收集参数: 普通收集参数:在形参当中，号后面的参数是收集参数，用于专门收集多余的普通参数,形成一个新的元组。语法:参数前面加 例:*args。 # 例子：计算任意个数的累加和 def my_sum(*args): total = 0 for i in args: total += i print(total) my_sum(1, 2, 3, 77, 11) 关键字收集参数:用于专门收集多余关键字实参的是关键字收集参数,形成一个新的字典。语法:参数前面加** 例:**kwargs。 # 例子：任意参数的拼接 def link_str(**kwargs): print(kwargs)#{&apos;monitor&apos;:&apos;zhangbojin&apos;,&apos;zhangsan&apos;:&apos;zhangsan&apos;,&apos;school_beauty&apos;:&apos;wangitechui&apos;} strvar1 = &apos;&apos; strvar2 = &apos;&apos; keydict = {&apos;monitor&apos;:&apos;班长&apos;,&apos;school_beauty&apos;:&apos;校花&apos;} for key,val in kwargs.items(): if key in keydict: strvar1 += keydict[key] + val + &apos;\n&apos; else: strvar2 += val print(strvar1+&quot;今天结婚,喜结良缘&quot;+&quot;,到场的吃瓜群众是&quot;+strvar2) link_str(monitor=&quot; 张铂金 &quot;,school_beauty=&quot; 王铁锤 &quot;,zhangsan = &apos;张三&apos; ) (3)命名关键字参数:定义时放在号后面的参数,调用时强制必须指定关键字实参才能调。在函数定义时，写在后面的参数2是命名关键字参数（假定参数3是关键字收集参数）语法:(*,x) x是命名关键字参数。作用：在函数调用的时候，必须使用关键字实参进行调用**保证参数3不是关键字收集参数时，那么此刻参数2，参数3都是命名关键字参数 (4)关于和**的 实参 调用:在调用时,容器类型数据前面加 或者 在函数的调用处：例：func2(*listvar, dictvar) 用在修改容器类型的数据，把容器里面的数据，一个一个拿出来，当成参数传递给函数** 用在修饰字典类型的数据，意味着把字典中的{键: 值} =&gt;变成键=值,一个个当成参数赋值给函数调用小案例 def func(a,b,*args,c,d):print(a,b) print(args) print(c) print(d) func(1,2,3,4,5,c=6,d=999)*号用法 print(“======”) listvar = [1, 2, 3] func1(*listvar)func1(*listvar) 等价于 func1(1, 2, 3)**号用法 dictvar = {‘d’: 4} func2(1, 2, 3, **dictvar)func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)函数的调用处 func2(listvar,**dictvar)(5)形参声明的位置顺序: 普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt; 命名关键字参数 -&gt; 关键字收集参数(6)对于任意函数，都可以通过 def func(args, **kw) 来获取所有参数参数练习：def f1(a, b, c=0, args, **kwargs): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)def f2(a, b, c=0, , d, *kw): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘d =’, d, ‘kw =’, kw)以上两个函数 打印结果#(一)f1(1, 2) #a = 1 b = 2 c = 0 args = () kw = {}f1(1, 2, c=3) #a = 1 b = 2 c = 3 args = () kw = {}f1(1, 2, 3, ‘a’, ‘b’) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {}f1(1, 2, 3, ‘a’, ‘b’, x=99) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99}f2(1, 2, d=99, ext=None) #a = 1 b = 2 c = 0 d = 99 kw = {‘ext’: None}#(二)args = (1, 2, 3, 4)kw = {‘d’: 99, ‘x’: ‘#’}f1(*args, **kw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}f1(1,2,3,4,d=99,x=’#’)#(三)myargs = (1, 2, 3)mykw = {‘d’: 88, ‘x’: ‘#’}f2(*myargs, **mykw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}f2(1,2,3,d=88,x=’#’)#(四)def f1(a, b, c=0, *args,d,**kw): print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw) print(d)f1(1,2,3, ‘a’, ‘b’,d=67, x=99,y=77) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99, ‘y’: 77} return返回值为这个函数返回一个结果 (return返回值可有可无 按照需求选择)注意:执行return语句之后,函数执行结束 doc：doc或者help查看文档 全局变量、局部变量及其关键字的使用– global 关键字:声明全局变量,作用在于修改全局变量– nonlocal 关键字:声明函数内部的局部变量,作用在于修改局部变量(当前函数上一层的局部变量) 内部函数(1)内部函数可以直接在函数外部调用么(2)调用外部函数后,内部函数可以在函数外部调用吗(3)内部函数可以在函数内部调用吗(4)内部函数在函数内部调用时,是否有先后顺序 闭包闭包的定义:内函数使用外函数的局部变量，并且外函数将内函数返回出来的方法叫闭包,返回的内函数叫闭包函数。闭包的特点:外函数的临时变量会在将来的内部函数中用到,自己调用结束后会把外函数的临时变量与内函数绑定,不释放将来调用内函数的时候仍可使用外函数变量。闭包的意义:闭包可以优先使用外函数中的变量,并对闭包中的值起到了封装保护的作用.外部无法访问。 递归函数递归的定义：自己调用自己就是递归函数。递归的注意事项：函数调用的过程就是开辟栈帧和释放栈帧的过程，调用结束时开辟栈帧空间，结束时释放（话外之意是不结束这层栈帧不释放）。递归每次调用都会开辟一个栈帧，如果递归的层数过多，不建议使用，容易内存溢出。每次开辟的栈帧空间，代码必须全部执行完毕之后才释放空间，在回到上一个栈帧执行没结束的代码。如果使用递归，需要给予一个跳出的条件，不能无限递归。 匿名函数实际上就是通过lambda表达式来书写的。一般只用来实现一些简单的函数功能，写法非常方便。 迭代器：定义：能被next()函数调用并且不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）。特征：迭代器会生成惰性序列，它通过计算把值依次地返回，一边循环一边计算而不是一次性得到所有数据。优点：需要数据的时候，一次取一个，可以大大节省内存空间，而不是一股脑地把所有数据放进内存。‘惰性序列：没有一次性的把所有数据都放在序列中，而是遍历一个放一个，这样的序列叫做惰性序列。Iterable可迭代性 Iterator迭代器range是可迭代对象range和迭代器能够产生惰性序列]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python OS模块常用方法总结]]></title>
    <url>%2F2018%2F10%2F14%2FPython%20OS%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[os模块是与操作系统交互的一个接口。下面是关于对文件路径、文件夹等的相关操作及说明。 操作 说明 os.getcwd() 得到当前工作目录，即当前Python脚本工作的目录路径 os.listdir() 返回指定目录下的所有文件和目录名 os.remove() 函数用来删除一个文件 os.removedirs(r”c\python”) 删除多个目录 os.path.isfile() 检验给出的路径是否是一个文件 os.path.isdir() 检验给出的路径是否是一个目录 os.path.isabs() 判断是否是绝对路径 os.path.exists() 检验给出的路径是否真地存 os.path.split() 返回一个路径的目录名和文件名 os.path.splitext() 分离扩展名 os.path.dirname() 获取路径名 os.path.basename() 获取文件名 os.system() 运行shell命令 os.getenv()与os.putenv() 读取和设置环境变量 os.linesep 给出当前平台使用的行终止符，Windows使用’rn’，Linux使用’n’而Mac使用’r’ os.name 指示你正在使用的平台，对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ os.rename(old, new) 重命名： os.makedirs(r”c：\python\test”) 创建多级目录 os.mkdir(“test”) 创建单个目录 os.stat(file) 获取文件属性 os.chmod(file) 修改文件权限与时间戳 os.exit() 终止当前进程 os.path.getsize(filename) 获取文件大小 os.mkdir(“file”) 创建目录 os.rename(“oldname”,”newname”) 重命名文件（目录）,文件或目录都是使用这条命令 os.remove(“file”) 删除文件 os.rmdir(“dir”) 删除目录, 只能删除空目录 os.chdir(“path”) 转换目录, 换路径 os.mknod(“test.txt”) 创建空文件]]></content>
      <categories>
        <category>Python</category>
        <category>内置模块</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5/CSS3新特性、移除的元素及兼容问题]]></title>
    <url>%2F2018%2F10%2F14%2FHTML5CSS3_001%2F</url>
    <content type="text"><![CDATA[HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有： 绘画canvas元素 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、searchCSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。移除的元素包括： 纯表现的元素 basefont、big、center、font、 s、strike、tt、u； 对可用性产生负面影响的元素 frame、frameset、noframes。浏览器兼容问题解决方案：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式，当然最好的方式是直接使用成熟的框架： 123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>HTML5/CSS3</tag>
      </tags>
  </entry>
</search>
