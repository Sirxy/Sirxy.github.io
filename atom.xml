<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐雨橙风</title>
  
  <subtitle>水滴石穿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sirxy.github.io/"/>
  <updated>2019-04-07T04:49:12.308Z</updated>
  <id>http://sirxy.github.io/</id>
  
  <author>
    <name>Sirxy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python网络爬虫之——认识urllib库</title>
    <link href="http://sirxy.github.io/2019/04/07/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86urllib%E5%BA%93/"/>
    <id>http://sirxy.github.io/2019/04/07/Python网络爬虫之——认识urllib库/</id>
    <published>2019-04-07T04:22:58.000Z</published>
    <updated>2019-04-07T04:49:12.308Z</updated>
    
    <content type="html"><![CDATA[<p>不说废话，耿直，直接上案例。<br><a id="more"></a></p><h3 id="案例1：百度首页爬取"><a href="#案例1：百度首页爬取" class="headerlink" title="案例1：百度首页爬取"></a>案例1：百度首页爬取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#  导包</span><br><span class="line">from urllib import request</span><br><span class="line"># 确定爬取资源</span><br><span class="line">base_url = &apos;http://www.baidu.com&apos;</span><br><span class="line"># 构建请求 发送请求</span><br><span class="line">response = request.urlopen(base_url)</span><br><span class="line"># 接受响应信息</span><br><span class="line">html = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line">print(html)   # 返回的是html源代码  </span><br><span class="line"># 信息存储</span><br><span class="line">with open(&apos;./baidu.html&apos;,&apos;w&apos;,encodeing=&apos;utf-8&apos;) as f:</span><br><span class="line">    f.wirte(html) </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">### 案例2：get请求中url带中文字符</span><br><span class="line">实现百度搜索。url地址会将url中的中文字符进行编码，所以当我们使用urllib发送此类url请求前要讲中文字符进行编码。</span><br></pre></td></tr></table></figure><p>from urllib import request, parse #  1.导包<br>base_url = ‘<a href="http://www.baidu.com/s?&#39;" target="_blank" rel="noopener">http://www.baidu.com/s?&#39;</a> # 2.确定爬取资源<br>inp = input(‘输入搜索内容:’)<br>msg = { # 3.构造请求参数<br>    ‘wd’: inp<br>}<br>encodemsg = parse.urlencode(msg)<br>newurl = base_url+encodemsg # 将编码后的参数进行拼接<br>response = request.urlopen(newurl) #4. 构建请求 发送请求<br>html = response.read().decode(‘utf-8’) # 5.接受响应信息<br>print(html)   # 返回的是html源代码<br>with open(‘./baidu.html’, ‘w’, encodeing=’utf-8’) as f: # 信息存储<br>    f.wirte(html)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 案例3：带user-agent反爬的网站</span><br><span class="line">带有user-agent反爬的网站在发送请求之前必须要构建自己的请求头。</span><br></pre></td></tr></table></figure></p><h1 id="1-导包"><a href="#1-导包" class="headerlink" title="1.导包"></a>1.导包</h1><p>from urllib import request</p><h1 id="2-确定爬取资源"><a href="#2-确定爬取资源" class="headerlink" title="2.确定爬取资源"></a>2.确定爬取资源</h1><p>base_url = ‘<a href="http://www.xicidaili.com&#39;" target="_blank" rel="noopener">http://www.xicidaili.com&#39;</a></p><h1 id="3-构造请求头与请求"><a href="#3-构造请求头与请求" class="headerlink" title="3.构造请求头与请求"></a>3.构造请求头与请求</h1><p>headers = {<br>    ‘User-Agent’: ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36’<br>}<br>req = request.Request(url=base_url, headers=headers)</p><h1 id="4-发送请求"><a href="#4-发送请求" class="headerlink" title="4.发送请求"></a>4.发送请求</h1><p>html = request.urlopen(req)</p><h1 id="5-接受并存储信息"><a href="#5-接受并存储信息" class="headerlink" title="5.接受并存储信息"></a>5.接受并存储信息</h1><p>with open(‘./xici.html’,’w’,encodeing=’utf-8’) as f:<br>    f.write(html)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 案例4：以上都是get请求 接下来做百度翻译(post请求)</span><br><span class="line">先通过抓包工具F12 newwork分析，找到翻译时发送的请求，因为是异步请求又是post请求，所以还要找到传递的参数。直接上代码：</span><br></pre></td></tr></table></figure></p><p>from urllib import request,parse<br>import ssl,json<br>ssl._create_default_https_context = ssl._create_unverified_context</p><h1 id="确定爬取地址"><a href="#确定爬取地址" class="headerlink" title="确定爬取地址"></a>确定爬取地址</h1><p>base_url = ‘<a href="https://fanyi.baidu.com/sug&#39;" target="_blank" rel="noopener">https://fanyi.baidu.com/sug&#39;</a><br>def fanyi(msg):</p><pre><code># 构造数据dataform = {    &apos;kw&apos;: msg}newdataform = parse.urlencode(dataform)# 发送请求response =  request.urlopen(url=base_url, data=bytes(newdataform, encoding=&apos;utf-8&apos;))# 接受返回的数据res = response.read().decode(&apos;utf-8&apos;)newres = json.loads(res)# print(json.loads(res), type(json.loads(res)))str = &apos;&apos;for item in newres[&apos;data&apos;]:    str += item[&apos;v&apos;] + &apos;\n&apos;print(str)</code></pre><h1 id="将字典类型转换成字符串"><a href="#将字典类型转换成字符串" class="headerlink" title="将字典类型转换成字符串"></a>将字典类型转换成字符串</h1><h1 id="print-json-dumps-newres-indent-4-ensure-ascii-False"><a href="#print-json-dumps-newres-indent-4-ensure-ascii-False" class="headerlink" title="print(json.dumps(newres, indent=4, ensure_ascii=False))"></a>print(json.dumps(newres, indent=4, ensure_ascii=False))</h1><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    while True:<br>        msg = input(‘请输入要翻译的单词：’)</p><pre><code># 按q退出if msg == &apos;q&apos;:    breakfanyi(msg)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：如果发送请求时出现如下错误：</span><br></pre></td></tr></table></figure><p>urllib.error.URLError: <urlopen error="" [ssl:="" certificate_verify_failed]="" certificate="" verify="" failed="" (_ssl.c:777)=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是因为ssl 验证的错误，可以将下面代码粘贴，解决不进行验证：</span><br></pre></td></tr></table></figure></urlopen></p><p>ssl._create_default_https_context = ssl._create_unverified_context<br><code>`</code></p><p>练习：爬取百度贴吧，根据用户输入的贴吧名称，页码范围来爬取指定贴吧指定页数范围。<br>爬取豆瓣电影的数据，这个是豆瓣电影的api:<a href="https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=" target="_blank" rel="noopener">https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不说废话，耿直，直接上案例。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://sirxy.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python爬虫" scheme="http://sirxy.github.io/tags/Python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之——socket套接字</title>
    <link href="http://sirxy.github.io/2019/04/07/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E2%80%94%E2%80%94socket%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>http://sirxy.github.io/2019/04/07/网络通信之——socket套接字/</id>
    <published>2019-04-07T04:00:22.000Z</published>
    <updated>2019-04-07T04:40:42.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h3><p>socket(简称 套接字)是一个网络通信的端点，它能实现不同主机间的进程通信，我们网络上各种各样大多数都是基于Socket来完成的通讯。<br><a id="more"></a></p><h3 id="网络中进程之间如何通讯呢？"><a href="#网络中进程之间如何通讯呢？" class="headerlink" title="网络中进程之间如何通讯呢？"></a>网络中进程之间如何通讯呢？</h3><p>首要解决的问题是如何确定你要和对方电脑上哪个进程进行通讯，这主要是<br>利用协议，IP地址，端口标识网络的进程，然后通过这些标识进行通讯。</p><h4 id="socket——UDP网络通讯"><a href="#socket——UDP网络通讯" class="headerlink" title="socket——UDP网络通讯"></a>socket——UDP网络通讯</h4><p>使用socket创建UDP通讯的过程很简单，如下图：<br><img src="/2019/04/07/网络通信之——socket套接字/socket-udp.png" alt="socket——UDP网络通讯示意图"><br>根据上图我们可以总结创建服务端和客户端的步骤，使用代码分别实现服务端和客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line">1.创建套接字对象</span><br><span class="line">2.绑定ip地址和端口号</span><br><span class="line">3.接受消息</span><br><span class="line">4.返回消息</span><br><span class="line">5.关闭套接字</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"># 创建套接字</span><br><span class="line">udp_s = socket.socked(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"># 绑定ip地址</span><br><span class="line">udp_s.bind((&apos;&apos;,8080))</span><br><span class="line"># 接受消息</span><br><span class="line">data,addr = udp_s.recvfrom(1024)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"># 关闭套接字</span><br><span class="line">udp_s.close()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">客户端：</span><br><span class="line">1.创建套接字对象</span><br><span class="line">2.发送消息</span><br><span class="line">3.关闭套接字对象</span><br><span class="line"></span><br><span class="line">import socekd</span><br><span class="line"># 创建套接字对象</span><br><span class="line">udp_c = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"># 发送消息</span><br><span class="line">udp_c.sendto(&apos;hello&apos;.encode(&apos;utf-8&apos;),(&apos;192.168.1.15&apos;,8080))</span><br><span class="line"># 关闭套接字</span><br><span class="line">udp_c.close()</span><br></pre></td></tr></table></figure><h4 id="Socket–TCP网络通讯"><a href="#Socket–TCP网络通讯" class="headerlink" title="Socket–TCP网络通讯"></a>Socket–TCP网络通讯</h4><p>TCP通讯过程如下图：<br><img src="/2019/04/07/网络通信之——socket套接字/socket-tcp.png" alt="socket——TCP网络通信示意图"><br>从图上可以看出，创建服务端通信需要经过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.创建套接字对象</span><br><span class="line">2.绑定ip地址和端口号</span><br><span class="line">3.监听</span><br><span class="line">4.接受消息</span><br><span class="line">5.返回消息</span><br><span class="line">6.关闭套接字</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">tcp_s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">tcp_s.bind((&apos;&apos;,8080))</span><br><span class="line">tcp_s.listen()</span><br><span class="line">s,addr = tcp_s.accept()</span><br><span class="line">data = s.recv(1024)</span><br><span class="line">print(data.decode(&apos;utf-8&apos;))</span><br><span class="line">s.send(&apos;hello&apos;.encode(&apos;utf-8))</span><br><span class="line">s.close()</span><br><span class="line">tcp_s.close()</span><br><span class="line">``` </span><br><span class="line">创建客户端通信需要经过：</span><br><span class="line">```    </span><br><span class="line">1.创建套接字对象</span><br><span class="line">2.创建连接</span><br><span class="line">3.发送消息</span><br><span class="line">4.关闭套接字对象</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">tcp_c = socket.socket(socket.AF_INET,socket.SOCK_STRAM)</span><br><span class="line">tcp_c.connect((&apos;192.168.1.15&apos;,8080))</span><br><span class="line">tcp_c.send(&apos;hello&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">tcp_c.close()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是Socket&quot;&gt;&lt;a href=&quot;#什么是Socket&quot; class=&quot;headerlink&quot; title=&quot;什么是Socket&quot;&gt;&lt;/a&gt;什么是Socket&lt;/h3&gt;&lt;p&gt;socket(简称 套接字)是一个网络通信的端点，它能实现不同主机间的进程通信，我们网络上各种各样大多数都是基于Socket来完成的通讯。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络通信" scheme="http://sirxy.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="网络通信学习" scheme="http://sirxy.github.io/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之——UDP和TCP</title>
    <link href="http://sirxy.github.io/2019/04/07/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E2%80%94%E2%80%94UDP%E5%92%8CTCP/"/>
    <id>http://sirxy.github.io/2019/04/07/网络协议之——UDP和TCP/</id>
    <published>2019-04-07T03:49:03.000Z</published>
    <updated>2019-04-07T04:03:31.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UDP协议和TCP协议"><a href="#UDP协议和TCP协议" class="headerlink" title="UDP协议和TCP协议"></a>UDP协议和TCP协议</h3><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP：用户数据报协议，不可靠性，只是把应用程序传给IP层数据报送出去，但是不能保证他们是否能到达目的地<a id="more"></a>，传输数据报前不用再客户端和服务器之间建立连接，并且没有超时重发机制，所以传输速度快。<br>特点：安全性差，传输速度快，无序，大小有限制64kb。</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>我们知道，在通讯之前，一定要先建立相关链接，才能发送数据。</p><p>下面是tcp建立连接 三次握手的概述：<br><img src="/2019/04/07/网络协议之——UDP和TCP/threehand.png" alt="tcp三次握手，建立连接"><br>其中：ACK：确认标志，SYN：同步标志<br>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；<br>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包<br>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。<br>完成三次握手，主机A与主机B开始传送数据。<br>特点：安全性高，稳定性好，有序；速度相对较慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UDP协议和TCP协议&quot;&gt;&lt;a href=&quot;#UDP协议和TCP协议&quot; class=&quot;headerlink&quot; title=&quot;UDP协议和TCP协议&quot;&gt;&lt;/a&gt;UDP协议和TCP协议&lt;/h3&gt;&lt;h4 id=&quot;UDP协议&quot;&gt;&lt;a href=&quot;#UDP协议&quot; class=&quot;headerlink&quot; title=&quot;UDP协议&quot;&gt;&lt;/a&gt;UDP协议&lt;/h4&gt;&lt;p&gt;UDP：用户数据报协议，不可靠性，只是把应用程序传给IP层数据报送出去，但是不能保证他们是否能到达目的地&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://sirxy.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议学习" scheme="http://sirxy.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://sirxy.github.io/2019/04/06/git01/"/>
    <id>http://sirxy.github.io/2019/04/06/git01/</id>
    <published>2019-04-06T04:35:25.000Z</published>
    <updated>2019-04-06T12:24:12.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一张git版本控制常用命令图送给你"><a href="#一张git版本控制常用命令图送给你" class="headerlink" title="一张git版本控制常用命令图送给你"></a>一张git版本控制常用命令图送给你</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了<a id="more"></a>帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br>下面是一张关于git版本控制的常用命令表：<br><img src="/2019/04/06/git01/b00-git-cheat-sheet-zh-cn.jpg" alt="版本控制git常用命令"></p><blockquote><p>参考自：<a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git教程|菜鸟教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一张git版本控制常用命令图送给你&quot;&gt;&lt;a href=&quot;#一张git版本控制常用命令图送给你&quot; class=&quot;headerlink&quot; title=&quot;一张git版本控制常用命令图送给你&quot;&gt;&lt;/a&gt;一张git版本控制常用命令图送给你&lt;/h3&gt;&lt;p&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;br&gt;Git 是 Linus Torvalds 为了&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://sirxy.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git版本控制" scheme="http://sirxy.github.io/tags/git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python面向对象——super()</title>
    <link href="http://sirxy.github.io/2019/04/05/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94super/"/>
    <id>http://sirxy.github.io/2019/04/05/Python面向对象——super/</id>
    <published>2019-04-05T02:25:02.000Z</published>
    <updated>2019-04-05T05:59:01.051Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python-OOP中关于super-的描述"><a href="#Python-OOP中关于super-的描述" class="headerlink" title="Python OOP中关于super()的描述"></a>Python OOP中关于super()的描述</h3><p>在Python OOP实际应用中，有一个函数super()，通过这个函数可以允许继承父类的子类访问该父类中的方法。super()会在该子类当中单独返回一个父类的临时对象，然后允许你在该子类中调用该父类所拥有的方法。<a id="more"></a>通常使用super()这个函数调用父类当中所构建的方法，这可以使你无需在子类中重写这些方法，并允许你使用最少的代码更改来替换父类。在对Python super()有了一个大致的认识后，下面说一说Python中关于各种继承（单继承、多继承）对super()的简单应用等。</p><h3 id="Python单继承之super"><a href="#Python单继承之super" class="headerlink" title="Python单继承之super()"></a>Python单继承之super()</h3><p>首先来定义两个类：Rectangle、Square，通过这两个类来说明继承关系。定义类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, height):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line">class Square():</span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.length</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return self.length &lt;&lt; 2</span><br><span class="line"></span><br><span class="line">square = Square(4) # 实例化正方形类</span><br><span class="line">print(square.area())</span><br><span class="line">rectangle = Rectangle(2, 4) # 实例化矩形类</span><br><span class="line">print(rectangle.area())</span><br></pre></td></tr></table></figure></p><p>通过此示例发现，这两个类是两个相互有关联的形状类：正方形是一种特殊的矩形， 但以上的代码似乎并没有展示出这种关系，因此这两个类具有重复的代码。找出了相关性，我们就可以通过这种相关性类实现继承的关系，通过继承减少代码的量的编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super().__init__(length, length)</span><br><span class="line"></span><br><span class="line">square = Square(4) # 实例化正方形类</span><br><span class="line">print(square.area())</span><br><span class="line">rectangle = Rectangle(2, 4) # 实例化矩形类</span><br><span class="line">print(rectangle.area())</span><br></pre></td></tr></table></figure></p><p>在这里，我们使用了super()来调用Rectangle类的<strong>init </strong>()，允许我们在Square类中使用它而不重复代码。 如下所示，核心功能在进行更改后仍然存在。<br>因为Square和Rectangle .<strong> init </strong>()方法非常相似，所以你可以使用super()从Square的方法中调用超类的.<strong> init </strong>()方法（Rectangle .<strong> init </strong>()）。 这里设置了.length和.width属性，即使您只需要为Square构造函数提供单个长度参数。<br>当你运行它时，即使你的Square类没有显式地实现它，对.area()的调用将使用超类中的.area()方法并打印16. Square类从Rectangle继承.area() 方法。</p><h3 id="super-在单继承中能为你做什么呢？"><a href="#super-在单继承中能为你做什么呢？" class="headerlink" title="super()在单继承中能为你做什么呢？"></a>super()在单继承中能为你做什么呢？</h3><p>与其他面向对象语言一样，它允许您在子类中调用父类的方法。这种情况的主要用例是扩展继承方法的功能。<br>在下面的示例中，您将创建一个继承自Square的类Cube，并扩展.area()的功能（通过Square继承自Rectangle类）以计算Cube实例的表面积和体积：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super().__init__(length, length)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cube(Square):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;立方体类&apos;&apos;&apos;</span><br><span class="line">def surface_area(self):</span><br><span class="line">&apos;&apos;&apos;计算表面积&apos;&apos;&apos;</span><br><span class="line">face_area = super().area()</span><br><span class="line">return face_area * 6</span><br><span class="line"></span><br><span class="line">def volume(self):</span><br><span class="line">face_area = super().area()</span><br><span class="line">return face_area * self.length</span><br></pre></td></tr></table></figure></p><p>这时，让我们看一下边长为3的立方体的表面积和体积：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cube = Cube(3)</span><br><span class="line">print(cube.surface_area()) # 54</span><br><span class="line">print(cube.volume()) # 27</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，我们为Cube立方体类实现了两个方法：.surface_area()和.volume()。这两个计算都依赖于计算单个面的面积，因此您不必重新实现面积计算，而是使用super()来扩展面积计算。<br>另外请注意，Cube类定义没有.<strong> init </strong>()。因为Cube继承自Square，而.<strong> init </strong>()并没有为Cube做任何不同的事情，所以你可以跳过定义它，并且将自动调用超类（Square）的.<strong> init </strong>()。<br>super()将委托对象返回给父类，因此您可以直接调用它所需的方法：super().area()。这不仅使我们不必重写面积计算方法，而且还允许我们在一个位置更改内部.area()逻辑。当你有一些继承自一个父类的子类时，这尤其有用。<br>介绍了上面这些示例，下面我们探索一下super()它的机制。</p><h3 id="super-机制"><a href="#super-机制" class="headerlink" title="super()机制"></a>super()机制</h3><p>我们发现，上面一系列的示例是在没有任何参数的情况下调用super()的，然而super()也可以使用两个参数：第一个是子类，第二个参数是作为该子类实例的对象。<br>首先，让我们看两个示例，通过使用已有的类来展示操作第一个变量可以做什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super(Square, self).__init__(length, length)</span><br></pre></td></tr></table></figure></p><p>在Python 3当中，super(Square，self)调用等同于无参数的super()调用。 第一个参数指的是子类Square，而第二个参数指的是Square对象，在这种情况下，它是self。 我们也可以使用其他类调用super()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Cube(Square):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;立方体类&apos;&apos;&apos;</span><br><span class="line">def surface_area(self):</span><br><span class="line">&apos;&apos;&apos;计算表面积&apos;&apos;&apos;</span><br><span class="line">face_area = super(Square, self).area()</span><br><span class="line">return face_area * 6</span><br><span class="line"></span><br><span class="line">def volume(self):</span><br><span class="line">face_area = super(Square, self).area()</span><br><span class="line">return face_area * self.length</span><br></pre></td></tr></table></figure></p><p>在此示例中，您将Square设置为super()的子类参数，而不是Cube。 这导致super()开始在实例层次结构中的Square上方的一个级别搜索匹配方法（在本例中为.area()方法），在本例中为Rectangle类。在此特定示例中，行为不会更改。 但想象一下Square还实现了一个你想要确保Cube不使用的.area()方法。 以这种方式调用super()可以让你这样做。<br>第二个参数怎么样？请记住，这是一个对象，它是用作第一个参数的类的实例。例如，isinstance(Cube，Square)必须返回True。<br>通过包含实例化对象，super()返回一个绑定方法：绑定到对象的方法，用来为方法提供对象的上下文，例如任何实例属性。如果未包含此参数，则返回的方法只是一个函数，与对象的上下文无关。（注意：super()不返回方法。它返回一个代理对象。它将调用正确的类方法，而不需要另外创建一个对象。）</p><h3 id="Python多继承之super"><a href="#Python多继承之super" class="headerlink" title="Python多继承之super()"></a>Python多继承之super()</h3><p>了解了单继承的super()和它的一些示例，下面，我们将开始了解多继承的一些概述和一些示例，这些示例将演示多继承如何工作以及super()如何启用该功能。</p><ul><li>多继承概述<br>Python支持多继承，其中子类可以从多个不必继承的超类（也称为兄弟类）继承。<br>为了更好地说明多继承的实际应用，下面将展示如何通过三角形和正方形构建一个右金字塔（带有方形底座的金字塔）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super().__init__(length, length)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Triangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;三角形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, height):</span><br><span class="line">self.base = base</span><br><span class="line">self.height = height</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">return self.base * self.height * 0.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RightPyramid(Triangle, Square):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;右金字塔类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, slant_height):</span><br><span class="line">self.base = base</span><br><span class="line"># 倾斜高度：从物体底部中心（如金字塔）到其面部到该物体顶部的高度</span><br><span class="line">self.slant_height = slant_height </span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">perimeter = super().perimeter()</span><br><span class="line">return perimeter * self.slant_height * 0.5 + base_area</span><br></pre></td></tr></table></figure></li></ul><p>此示例原来的基础上又声明了一个Triangle类和一个继承Square和Triangle的RightPyramid类。<br>您将看到另一个使用super()的.area()方法，就像在单继承中一样，目的是用到在Rectangle类中一直定义的.perimeter()和.area()方法。<br>但问题是两个超类（Triangle和Square）都定义了一个.area()。花一点时间思考在RightPyramid上调用.area()时会发生什么，然后尝试调用它，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pyramid = RightPyramid(2, 4)</span><br><span class="line">print(pyramid.area())</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line">#   File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 103, in &lt;module&gt;</span><br><span class="line">#     print(pyramid.area())</span><br><span class="line">#   File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 99, in area</span><br><span class="line">#     base_area = super().area()</span><br><span class="line">#   File &quot;C:\Users\lenovo\Desktop\dianping.py&quot;, line 88, in area</span><br><span class="line">#     return self.base * self.height * 0.5</span><br><span class="line"># AttributeError: &apos;RightPyramid&apos; object has no attribute &apos;height&apos;</span><br></pre></td></tr></table></figure></p><p>您是否猜测Python会尝试调用Triangle.area()？ 这是因为所谓的方法解析顺序在起作用。<br>注意：我们怎么注意到Triangle.area()被调用了，而不是像我们希望的那样，Square.area()？ 如果查看回溯的最后一行（在AttributeError之前），您将看到对特定代码行的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return self.base * self.height * 0.5</span><br></pre></td></tr></table></figure></p><p>您可以将几何类中的这个方法认为是三角形面积公式。 或者，你可能已经找到Triangle和Rectangle类定义，并在Triangle.area()中看到了相同的代码。</p><ul><li>方法解析顺序mro<br>方法解析顺序告诉Python如何搜索继承来的方法，当你使用super()时，这回排上很大的用场，因为mro会告诉Python将使用super()以及以什么样的顺序来进行调用的方法。<br>每个类都会有一个.<strong>mro</strong>的魔术属性，它允许我们检查顺序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(RightPyramid.__mro__) </span><br><span class="line"># 打印结果：</span><br><span class="line">(&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure></li></ul><p>这告诉我们首先在Rightpyramid中搜索方法，然后在Triangle中搜索，然后在Square中搜索，然后在Rectangle中搜索，然后，如果没有找到，则在对象中搜索。</p><p>这里的问题是解释器在Square和Rectangle之前在Triangle中搜索.area()，并且在Triangle中找到.area()时，Python会调用它而不是你想要的那个。 因为Triangle.area()期望有.height和.base属性，所以Python会抛出AttributeError。</p><p>幸运的是，您可以控制MRO的构建方式。 只需更改RightPyramid类的签名，即可按所需顺序进行搜索，方法将正确解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class RightPyramid(Square, Triangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;右金字塔类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, slant_height):</span><br><span class="line">self.base = base</span><br><span class="line">self.slant_height = slant_height</span><br><span class="line">super().__init__(self.base)</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">perimeter = super().perimeter()</span><br><span class="line">return perimeter * self.slant_height * 0.5 + base_area</span><br></pre></td></tr></table></figure></p><p>请注意，RightPyramid使用Square类中的.<strong> init </strong>()进行部分初始化。 这允许.area()在对象上使用.length，如设计的那样。</p><p>现在，您可以构建金字塔类，检查MRO并计算表面积：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyramid = RightPyramid(2, 4)</span><br><span class="line">print(pyramid.area()) # 20.0</span><br><span class="line">print(RightPyramid.__mro__) # (&lt;class &apos;__main__.RightPyramid&apos;&gt;, &lt;class &apos;__main__.Square&apos;&gt;, &lt;class &apos;__main__.Rectangle&apos;&gt;, &lt;class &apos;__main__.Triangle&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure></p><p>您可以看到MRO现在是您所期望的，并且您也可以检查金字塔的表面积，这要归功于.area()和.perimeter()。</p><p>不过，这里仍然存在问题。为了简单起见，我在这个例子中故意设置了一些错误：第一个，可以说最重要的是，我有两个具有相同方法名称和签名的独立类。</p><p>这会导致方法解析问题，因为将调用MRO列表中遇到的.area()的第一个实例。</p><p>当您使用具有多重继承的super()时，必须设计您的类以进行协作。其中一点是确保您的方法是唯一的，以便通过签名确保方法是唯一的 - 无论是使用方法名称还是方法参数，在MRO中正确解析它们。</p><p>在这种情况下，为了避免对代码进行彻底检查，可以将Triangle类的.area()方法重命名为.tri_area()。这样，area方法可以继续使用类属性而不是使用外部参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Triangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;三角形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, height):</span><br><span class="line">self.base = base</span><br><span class="line">self.height = height</span><br><span class="line">super().__init__()</span><br><span class="line"></span><br><span class="line">def tri_area(self):</span><br><span class="line">return self.base * self.height * 0.5</span><br></pre></td></tr></table></figure></p><p>让我们继续在RightPyramid类中使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class RightPyramid(Square, Triangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;右金字塔类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, slant_height):</span><br><span class="line">self.base = base</span><br><span class="line">self.slant_height = slant_height</span><br><span class="line">super().__init__(self.base)</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">perimeter = super().perimeter()</span><br><span class="line">return perimeter * self.slant_height * 0.5 + base_area</span><br><span class="line">def area_2(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">triangle_area = super().tri_area()</span><br><span class="line">return triangle_area * 4 + base_area</span><br></pre></td></tr></table></figure></p><p>这里的下一个问题是代码没有像Square对象那样的委托的Triangle对象，所以调用.area_2()会给我们一个AttributeError，因为.base和.height没有任何值。</p><p>你需要做两件事来解决这个问题：</p><p>1.使用super()调用的所有方法都需要调用其超类的该方法版本。 这意味着您需要将super().<strong> init </strong>()添加到Triangle和Rectangle的.<strong> init </strong>()方法中。</p><p>2.重新设计所有.<strong> init </strong>()调用以获取关键字字典。 请参阅下面的完整代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length, **kwargs):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line">super().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line">def perimeter(self):</span><br><span class="line">&apos;&apos;&apos;计算周长&apos;&apos;&apos;</span><br><span class="line">return (self.width + self.length) &lt;&lt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length, **kwargs):</span><br><span class="line">super().__init__(length=length, width=length, **kwargs)</span><br><span class="line"></span><br><span class="line">class Cube(Square):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;立方体类&apos;&apos;&apos;</span><br><span class="line">def surface_area(self):</span><br><span class="line">face_area = super().area()</span><br><span class="line">return face_area * 6</span><br><span class="line"></span><br><span class="line">def volume(self):</span><br><span class="line">face_area = super().area()</span><br><span class="line">return face_area * self.length</span><br><span class="line"></span><br><span class="line">class Triangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;三角形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, height, **kwargs):</span><br><span class="line">self.base = base</span><br><span class="line">self.height = height</span><br><span class="line">super().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">def tri_area(self):</span><br><span class="line">return self.base * self.height * 0.5</span><br><span class="line"></span><br><span class="line">class RightPyramid(Square, Triangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;右金字塔类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, base, slant_height, **kwargs):</span><br><span class="line">self.base = base</span><br><span class="line">self.slant_height = slant_height</span><br><span class="line">kwargs[&quot;height&quot;] = slant_height</span><br><span class="line">kwargs[&quot;length&quot;] = base</span><br><span class="line">super().__init__(base=base, **kwargs)</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">perimeter = super().perimeter()</span><br><span class="line">return perimeter * self.slant_height * 0.5 + base_area</span><br><span class="line"></span><br><span class="line">def area_2(self):</span><br><span class="line">base_area = super().area()</span><br><span class="line">triangle_area = super().tri_area()</span><br><span class="line">return triangle_area * 4 + base_area</span><br></pre></td></tr></table></figure></p><p>此代码中存在许多重要差异：</p><p>1.kwargs在某些地方被修改（例如RightPyramid .<strong> init </strong>()): 这将允许这些对象的用户仅使用对该特定对象有意义的参数来实例化它们。</p><p>2.在<strong>kwargs之前设置命名参数：你可以在RightPyramid .<strong> init </strong>()中看到这个。 这具有从</strong>kwargs字典中去除特定键的简洁效果，因此当它在MRO中最终进行到object时，**kwargs为空。<br>现在，当您使用这些更新的类时，您有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyramid = RightPyramid(base=2, slant_height=4)</span><br><span class="line">print(pyramid.area()) # 20</span><br><span class="line">print(pyramid.area_2()) # 20.0</span><br></pre></td></tr></table></figure></p><p>起作用了！ 您已经使用super()成功追溯复杂的类层次结构，同时使用继承和组合来创建具有最少重新实现的新类。</p><h3 id="多重继承替代方案"><a href="#多重继承替代方案" class="headerlink" title="多重继承替代方案"></a>多重继承替代方案</h3><p>如您所见，多重继承可能很有用，但也会导致非常复杂的情况和难以阅读的代码。 拥有整齐地从多个其他对象继承所有东西的对象也很少见。</p><p>如果您发现自己开始使用多重继承和复杂的类层次结构，那么值得问问自己是否可以通过使用组合而不是继承来实现更清晰，更易于理解的代码。</p><p>通过组合，您可以从一个称为mixin的专用简单类中为您的类添加非常特定的功能。</p><p>由于本文主要关注继承，因此我不会详细介绍组合以及如何在Python中使用它，但这里有一个使用VolumeMixin为我们的3D对象提供特定功能的简短示例 - 在这种情况下，是一个体积计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle():</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;矩形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, width, length):</span><br><span class="line">self.width = width</span><br><span class="line">self.length = length</span><br><span class="line"></span><br><span class="line">def area(self):</span><br><span class="line">&apos;&apos;&apos;计算面积&apos;&apos;&apos;</span><br><span class="line">return self.length * self.width</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Square(Rectangle):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;正方形类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super().__init__(length, length)</span><br><span class="line"></span><br><span class="line">class VolumeMixin():</span><br><span class="line">def volume(self):</span><br><span class="line">return self.area() * self.height</span><br><span class="line"></span><br><span class="line">class Cube(VolumeMixin, Square):</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;立方体类&apos;&apos;&apos;</span><br><span class="line">def __init__(self, length):</span><br><span class="line">super().__init__(length)</span><br><span class="line">self.height = length</span><br><span class="line"></span><br><span class="line">def surface_area(self):</span><br><span class="line">face_area = super().area()</span><br><span class="line">return face_area * 6</span><br><span class="line"></span><br><span class="line">def face_area(self):</span><br><span class="line">return super().area()</span><br></pre></td></tr></table></figure></p><p>在这个例子中，代码被重新设计为包含一个名为VolumeMixin的mixin。 然后，Cube使用mixin并使Cube能够计算其体积，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cube = Cube(2)</span><br><span class="line">print(cube.surface_area()) # 24</span><br><span class="line">print(cube.volume()) # 8</span><br></pre></td></tr></table></figure></p><p>这个mixin可以在任何需要计算体积的类中以相同的方式使用，并且公式area*height返回正确的结果。</p><p>有关Python中面向对象编程和使用super()的更多信息，请查看以下资源：</p><ul><li>官方的super()文档</li><li>由Raymond Hettinger写的Python的super()真的超赞</li><li>Python中面向对象的编程3</li></ul><blockquote><p>参考自：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NzU0MzU0Nw==&amp;mid=2651382106&amp;idx=1&amp;sn=0ac795103888e188f965ccc4f70f2875&amp;chksm=bd242a4e8a53a3582d999408bc939e9904960b5c7607c7a2b41bdfc72ca086721f9b76efae57&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">使用Python Super()为类提供继承支持</a> 译者：javylee<br><a href="https://realpython.com/python-super/" target="_blank" rel="noopener">英文原文</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python-OOP中关于super-的描述&quot;&gt;&lt;a href=&quot;#Python-OOP中关于super-的描述&quot; class=&quot;headerlink&quot; title=&quot;Python OOP中关于super()的描述&quot;&gt;&lt;/a&gt;Python OOP中关于super()的描述&lt;/h3&gt;&lt;p&gt;在Python OOP实际应用中，有一个函数super()，通过这个函数可以允许继承父类的子类访问该父类中的方法。super()会在该子类当中单独返回一个父类的临时对象，然后允许你在该子类中调用该父类所拥有的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python面向对象" scheme="http://sirxy.github.io/categories/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Python面向对象" scheme="http://sirxy.github.io/tags/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python模块——hashlib</title>
    <link href="http://sirxy.github.io/2019/04/04/Python%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94hashlib/"/>
    <id>http://sirxy.github.io/2019/04/04/Python模块——hashlib/</id>
    <published>2019-04-04T05:37:00.000Z</published>
    <updated>2019-04-04T13:37:12.039Z</updated>
    
    <content type="html"><![CDATA[<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1，SHA224，SHA256，SHA384，SHA512等等,用于加密数据。<br>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。<br><a id="more"></a><br>摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。<br>摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。<br>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">md5 = hashlib.md5(b&apos;how to use md5 in python hashlib?&apos;)</span><br><span class="line">password_md5 = md5.hexdigest()</span><br><span class="line">print(password_md5) # d26a53750bc40b38b65a520292f69306</span><br></pre></td></tr></table></figure><p>如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(b&apos;how to use md5 in &apos;)</span><br><span class="line">md5.update(b&apos;python hashlib?&apos;)</span><br><span class="line">print(md5.hexdigest()) # d26a53750bc40b38b65a520292f69306</span><br></pre></td></tr></table></figure></p><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(b&apos;how to use sha1 in &apos;)</span><br><span class="line">sha1.update(b&apos;python hashlib?&apos;)</span><br><span class="line">print(sha1.hexdigest()) # 2c76b57293ce30acef38d98f6046927161b46a44</span><br></pre></td></tr></table></figure></p><h3 id="摘要算法应用"><a href="#摘要算法应用" class="headerlink" title="摘要算法应用"></a>摘要算法应用</h3><p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name    | password</span><br><span class="line">--------+----------</span><br><span class="line">michael | 123456</span><br><span class="line">bob     | abc999</span><br><span class="line">alice   | alice2008</span><br></pre></td></tr></table></figure></p><p>如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username | password</span><br><span class="line">---------+---------------------------------</span><br><span class="line">michael  | e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">bob      | 878ef96e86145580c38c87f0410ad153</span><br><span class="line">alice    | 99b1c2188db85afee403b1536010c2c9</span><br></pre></td></tr></table></figure></p><p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;e10adc3949ba59abbe56e057f20f883e&apos;: &apos;123456&apos;</span><br><span class="line">&apos;21218cca77804d2ba1922c33e0151105&apos;: &apos;888888&apos;</span><br><span class="line">&apos;5f4dcc3b5aa765d61d8327deb882cf99&apos;: &apos;password&apos;</span><br></pre></td></tr></table></figure></p><p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。<br>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？<br>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashlib.md5(&quot;salt&quot;.encode(&quot;utf8&quot;))</span><br></pre></td></tr></table></figure></p><p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。<br>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？<br>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。<br>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的hashlib提供了常见的摘要算法，如MD5，SHA1，SHA224，SHA256，SHA384，SHA512等等,用于加密数据。&lt;br&gt;什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://sirxy.github.io/categories/Python/"/>
    
      <category term="内置模块" scheme="http://sirxy.github.io/categories/Python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="Python模块" scheme="http://sirxy.github.io/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python模块——sys</title>
    <link href="http://sirxy.github.io/2019/04/04/Python%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94sys/"/>
    <id>http://sirxy.github.io/2019/04/04/Python模块——sys/</id>
    <published>2019-04-04T05:31:07.000Z</published>
    <updated>2019-04-05T04:55:11.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>sys模块是与python解释器交互的一个接口。下面是常用的的一些接口解释：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(0),错误退出sys.exit(1)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform       返回操作系统平台名称</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sys模块&quot;&gt;&lt;a href=&quot;#sys模块&quot; class=&quot;headerlink&quot; title=&quot;sys模块&quot;&gt;&lt;/a&gt;sys模块&lt;/h3&gt;&lt;p&gt;sys模块是与python解释器交互的一个接口。下面是常用的的一些接口解释：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://sirxy.github.io/categories/Python/"/>
    
      <category term="内置模块" scheme="http://sirxy.github.io/categories/Python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="Python模块" scheme="http://sirxy.github.io/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>网站流量术语</title>
    <link href="http://sirxy.github.io/2019/04/04/HTTP%E5%AD%A6%E4%B9%A003/"/>
    <id>http://sirxy.github.io/2019/04/04/HTTP学习03/</id>
    <published>2019-04-04T01:46:13.000Z</published>
    <updated>2019-04-04T13:35:09.331Z</updated>
    
    <content type="html"><![CDATA[<p>网站统计一般以数值较大的IP,PV统计，比较好看。</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP即Internet Protocol，这里是指独立ip数，不同的ip地址的计算机访问网站时被计算的总次数。<br>独立ip数是网站流量的一个重要指标。<br>一般相同ip地址的客户端访问网站页面一天内只会被计算一次。<a id="more"></a><br>这里的ip指的是是固定的公网ip。</p><h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><p>pv（Page View）即是页面浏览量，不管客户端是不是相同，也不管ip是否相同，用户只要访问网站页面就会被计算PV，一次计算一个PV。<br>pv的度量方法就是客户端从浏览器发出一个web请求（request），服务器接收请求返回一个页面给客户端，这样就产生一个pv。<br>页面刷新一下，就是一个PV。</p><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p>UV即unique visitor，同一个客户端（pc或移动端）访问网站被计算为一个访客。<br>一天内相同的客户端访问同一个网站只计一次uv，uv是以cookie等技术为统计依据，实际统计存在误差。<br>一台计算机可能有多人使用，因此uv也不是最准确的。</p><h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>并发数指系统同时能处理的请求数量，也反应了系统的负载能力。</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>Query Per Second：每秒查询数<br>服务器在一秒内处理了多少个请求，显然数字越大代表服务器的负载越高，处理能力越强。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Http相关术语pv、ip、uv 假设公司有一座大厦，大厦有100人，每个人有一台电脑和一部手机，上网都是通过nat转换出口，每个人点击网站2次（发2次请求）, 请问对应的pv,uv,ip分别是多少？</span><br><span class="line"></span><br><span class="line">PV：页面浏览量, 400 100人 2个设备 访问2次 =400数</span><br><span class="line">uv：独立的客户, 200 100人2个设备=200数</span><br><span class="line">ip：独立IP, 1个 同一个NAT出口，独立IP为1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站统计一般以数值较大的IP,PV统计，比较好看。&lt;/p&gt;
&lt;h3 id=&quot;IP&quot;&gt;&lt;a href=&quot;#IP&quot; class=&quot;headerlink&quot; title=&quot;IP&quot;&gt;&lt;/a&gt;IP&lt;/h3&gt;&lt;p&gt;IP即Internet Protocol，这里是指独立ip数，不同的ip地址的计算机访问网站时被计算的总次数。&lt;br&gt;独立ip数是网站流量的一个重要指标。&lt;br&gt;一般相同ip地址的客户端访问网站页面一天内只会被计算一次。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://sirxy.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP学习" scheme="http://sirxy.github.io/tags/HTTP%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文、URI</title>
    <link href="http://sirxy.github.io/2019/04/03/HTTP%E5%AD%A6%E4%B9%A002/"/>
    <id>http://sirxy.github.io/2019/04/03/HTTP学习02/</id>
    <published>2019-04-03T13:50:12.000Z</published>
    <updated>2019-04-04T13:35:17.928Z</updated>
    
    <content type="html"><![CDATA[<p>什么是http报文？它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。<a id="more"></a></p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>由请求行，请求头部，空行，请求报文主体几个部分组成，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">起始行： &lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line"></span><br><span class="line">头部：   &lt;headers&gt;</span><br><span class="line"></span><br><span class="line">主体：   &lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态行</span><br><span class="line">响应头(Response Header)</span><br><span class="line">响应正文</span><br></pre></td></tr></table></figure></p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>uri中文叫“统一资源标识符”，是一个用于标识某一互联网资源名称的字符串，在世界范围内标识定位某一个唯一信息资源。<br>还有一个概念叫做URL，那什么是URL？URL简称统一资源定位符。那URL的组成部分是由协议, 域名:端口, 路径和文件名。<br>url主要用在各种www客户端和服务器程序上，url可以用一种统一的格式来描述各种信息资源，包括文件，服务器地址和目录等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是http报文？它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://sirxy.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP学习" scheme="http://sirxy.github.io/tags/HTTP%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP简介、特点、版本、请求方法、状态码</title>
    <link href="http://sirxy.github.io/2019/04/03/HTTP%E5%AD%A6%E4%B9%A001/"/>
    <id>http://sirxy.github.io/2019/04/03/HTTP学习01/</id>
    <published>2019-04-03T03:06:37.000Z</published>
    <updated>2019-04-04T13:35:25.395Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h3 id="一、Web服务基础"><a href="#一、Web服务基础" class="headerlink" title="一、Web服务基础"></a>一、Web服务基础</h3><p>用户访问网站的基本流程：</p><p>1、双击浏览器，输入目标网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在目标域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用<a id="more"></a><br>2、如果本地dns缓存和hosts文件都没有域名解析记录，系统就会把访问的网址解析请求发送给客户端设置的DNS服务器去解析，也叫做Local DNS，如果LDNS服务器的本地缓存有对应的解析记录就会直接返回给客户端IP地址，如果没有LDNS就会继续请求其他的DNS服务器<br>3、LDNS继续从DNS系统的”.”(根)开始请求目标域名的解析，并且根据每个层级的DNS服务器系统进行系列的查找，最终在DNS网络上找到目标域名对应的授权DNS服务器。这个授权DNS服务器就是企业（个人）购买域名时用于管理域名解析的服务器，服务器上有对应的域名（IP）解析。<br>4、此时授权的DNS服务器就会把目标对应的IP解析记录，例如（1.1.1.1）发送给LDNS<br>5、此时LDNS会把解析记录发给浏览器，并且缓存域名和IP的解析记录，便于下一次更快的返回请求<br>6、浏览器获得ip，请求对应的服务器，网站服务器接收到客户端的请求开始响应处理，将内容返回给浏览器。</p><h3 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h3><pre><code>全称是HyperText Tansfer Protocol,中文叫超文本传输协议，是互联网最常见的协议。Http最重要的是www(World Wide Web)服务，也叫web服务器，中文叫“万维网”。web服务端口默认是80，另外一个加密的www服务应用https默认端口是443，主要用于支付，网银相关业务。</code></pre><h3 id="三、HTTP协议的特点"><a href="#三、HTTP协议的特点" class="headerlink" title="三、HTTP协议的特点"></a>三、HTTP协议的特点</h3><p>　　1.HTTP协议是无状态的<br>　　就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。</p><p>　　2.多次HTTP请求<br>　　在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。</p><p>　　3.基于TCP协议<br>　　HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。</p><h3 id="四、版本"><a href="#四、版本" class="headerlink" title="四、版本"></a>四、版本</h3><pre><code>http协议诞生以来有若干个版本，主要是http/1.0 http/1.1http/1.0规定浏览器和服务器只能保持短暂的连接，浏览器的每次请求都需要和服务器建立一个TCP连接，服务器完成请求后即断开TCP连接，服务器不跟踪每个链接，也不记录请求http/1.1是对HTTP的缺陷进行重点修复，从可扩展性，缓存，带宽优化，持久连接，host头，错误通知等访问改进。http/1.1支持长连接，增加了更多的请求头和响应头信息，例如配置请求头的Connection的值为keep-alive，表示请求结果返回后保持连接</code></pre><h3 id="五、Http请求方法"><a href="#五、Http请求方法" class="headerlink" title="五、Http请求方法"></a>五、Http请求方法</h3><pre><code>在HTTP通信中，每个请求报文都包含一个方法，以告诉web服务器端需要执行哪些操作，这些动作被称为HTTP的请求方法。GET    请求指定的页面信息，并返回实体主体。HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT    从客户端向服务器传送的数据取代指定的文档的内容。DELETE    请求服务器删除指定的页面。CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS    允许客户端查看服务器的性能。TRACE    回显服务器收到的请求，主要用于测试或诊断。</code></pre><h3 id="六、HTTP状态码"><a href="#六、HTTP状态码" class="headerlink" title="六、HTTP状态码"></a>六、HTTP状态码</h3><pre><code>HTTP状态码表示web服务器响应http请求状态的数字代码。常见状态码以及作用：1**    信息，服务器收到请求，需要请求者继续执行操作2**    成功，操作被成功接收并处理3**    重定向，需要进一步的操作以完成请求4**    客户端错误，请求包含语法错误或无法完成请求5**    服务器错误，服务器在处理请求的过程中发生了错误</code></pre><h3 id="七、HTTP状态码的命令查看"><a href="#七、HTTP状态码的命令查看" class="headerlink" title="七、HTTP状态码的命令查看"></a>七、HTTP状态码的命令查看</h3><pre><code>$ curl -I www.oldboyedu.com</code></pre><ul><li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/和https://www.cnblogs.com/wxisme/p/6212797.html" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/和https://www.cnblogs.com/wxisme/p/6212797.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;## &lt;/p&gt;
&lt;h3 id=&quot;一、Web服务基础&quot;&gt;&lt;a href=&quot;#一、Web服务基础&quot; class=&quot;headerlink&quot; title=&quot;一、Web服务基础&quot;&gt;&lt;/a&gt;一、Web服务基础&lt;/h3&gt;&lt;p&gt;用户访问网站的基本流程：&lt;/p&gt;
&lt;p&gt;1、双击浏览器，输入目标网址后，系统首先会查找本地的DNS缓存以及hosts文件信息，确定是否存在目标域名对应的ip解析记录，如果有就直接获取ip进行访问服务器，第一次请求时，dns缓存是没有解析记录的，hosts文件多数是开发临时测试用&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://sirxy.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP学习" scheme="http://sirxy.github.io/tags/HTTP%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>nginx多个虚拟主机</title>
    <link href="http://sirxy.github.io/2019/04/03/nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9303/"/>
    <id>http://sirxy.github.io/2019/04/03/nginx学习总结03/</id>
    <published>2019-04-03T01:31:41.000Z</published>
    <updated>2019-04-04T13:34:20.814Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h3 id="Nginx多个虚拟主机"><a href="#Nginx多个虚拟主机" class="headerlink" title="Nginx多个虚拟主机"></a>Nginx多个虚拟主机</h3><p>想象一下，如果网站部署者在部署网站时，每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。于是就有了解决这种局面的办法：虚拟主机。虚拟主机就是将一台服务器分割成了多个“虚拟服务器”，每个站点可以使用各自的硬盘空间，由于节省资源、省钱，许多网站使用虚拟主机来部署网站。<a id="more"></a>虚拟主机的概念就是在web服务里的一个独立的网站站点，这个站点对应独立的域名（IP），具有独立的程序和资源目录，可以独立的对外提供服务。这个独立的站点配置是在nginx.conf中使用server{}代码块标签来表示一个虚拟主机。Nginx支持多个server{}标签，即支持多个虚拟主机站点。</p><h4 id="虚拟主机类型"><a href="#虚拟主机类型" class="headerlink" title="虚拟主机类型"></a>虚拟主机类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 基于域名的虚拟主机</span><br><span class="line">通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机。</span><br><span class="line"></span><br><span class="line">- 基于端口的虚拟主机</span><br><span class="line">通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:9000</span><br><span class="line"></span><br><span class="line">- 基于IP的虚拟主机</span><br><span class="line">通过不同的IP区分不同的虚拟主机，此类比较少见，一般业务需要多IP的常见都会在负载均衡中绑定VIP</span><br></pre></td></tr></table></figure><p>nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。<br>/etc/hosts是linux系统中本地dns解析的配置文件，同样可以达到域名访问效果。</p><p>修改nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">#配置文件内容如下</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #虚拟主机1</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pyyuc.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    #虚拟主机2</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pythonav;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy_python /opt/nginx1-12 14:52:12]#curl www.pythonav.cn</span><br><span class="line">&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内</span><br><span class="line">[root@oldboy_python /opt/nginx1-12 14:52:40]#curl www.pyyuc.cn</span><br><span class="line">&lt;meta charset=utf8&gt;我是pyyuc站点</span><br></pre></td></tr></table></figure><ul><li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;## &lt;/p&gt;
&lt;h3 id=&quot;Nginx多个虚拟主机&quot;&gt;&lt;a href=&quot;#Nginx多个虚拟主机&quot; class=&quot;headerlink&quot; title=&quot;Nginx多个虚拟主机&quot;&gt;&lt;/a&gt;Nginx多个虚拟主机&lt;/h3&gt;&lt;p&gt;想象一下，如果网站部署者在部署网站时，每台linux服务器只运行了一个小网站，那么人气低，流量小的草根站长需要承担高额的服务器租赁费，也造成了硬件资源浪费。于是就有了解决这种局面的办法：虚拟主机。虚拟主机就是将一台服务器分割成了多个“虚拟服务器”，每个站点可以使用各自的硬盘空间，由于节省资源、省钱，许多网站使用虚拟主机来部署网站。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://sirxy.github.io/categories/nginx/"/>
    
    
      <category term="Nginx学习" scheme="http://sirxy.github.io/tags/Nginx%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>nginx目录、部署站点</title>
    <link href="http://sirxy.github.io/2019/04/03/nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9302/"/>
    <id>http://sirxy.github.io/2019/04/03/nginx学习总结02/</id>
    <published>2019-04-03T00:52:04.000Z</published>
    <updated>2019-04-04T13:34:28.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="一、nginx软件目录"><a href="#一、nginx软件目录" class="headerlink" title="一、nginx软件目录"></a>一、nginx软件目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yc-virtual-machine /opt/nginx1-12 11:44:02]#ls</span><br><span class="line">client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp</span><br></pre></td></tr></table></figure><ul><li>conf 存放nginx所有配置文件的目录,主要nginx.conf</li><li>html 存放nginx默认站点的目录，如index.html、error.html等<a id="more"></a></li><li>logs 存放nginx默认日志的目录，如error.log access.log</li><li>sbin 存放nginx主命令的目录,sbin/nginx</li></ul><p>Nginx主配置文件/etc/nginx/nginx.conf是一个纯文本类型的文件，整个配置文件是以区块的形式组织的。一般，每个区块以一对大括号{}来表示开始与结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CoreModule核心模块</span><br><span class="line"></span><br><span class="line">user www;                       #Nginx进程所使用的用户</span><br><span class="line">worker_processes 1;             #Nginx运行的work进程数量(建议与CPU数量一致或auto)</span><br><span class="line">error_log /log/nginx/error.log  #Nginx错误日志存放路径</span><br><span class="line">pid /var/run/nginx.pid          #Nginx服务运行后产生的pid进程号</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events事件模块</span><br><span class="line"></span><br><span class="line">events &#123;            </span><br><span class="line">    worker_connections  //每个worker进程支持的最大连接数</span><br><span class="line">    use epool;          //事件驱动模型, epoll默认</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http内核模块</span><br><span class="line"></span><br><span class="line">// 公共的配置定义在http&#123;&#125;</span><br><span class="line">http &#123;  //http层开始</span><br><span class="line">...    </span><br><span class="line">    // 使用Server配置网站, 每个Server&#123;&#125;代表一个网站(简称虚拟主机)</span><br><span class="line">    &apos;server&apos; &#123;</span><br><span class="line">        listen       80;        // 监听端口, 默认80</span><br><span class="line">        server_name  localhost; // 提供服务的域名或主机名</span><br><span class="line">        access_log host.access.log  // 访问日志</span><br><span class="line">        // 控制网站访问路径</span><br><span class="line">        &apos;location&apos; / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;   // 存放网站代码路径</span><br><span class="line">            index  index.html index.htm;    // 服务器返回的默认页面文件</span><br><span class="line">        &#125;</span><br><span class="line">        // 指定错误代码, 统一定义错误页面, 错误代码重定向到新的Locaiton</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    //第二个虚拟主机配置</span><br><span class="line">    &apos;server&apos; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;  // 包含/etc/nginx/conf.d/目录下所有以.conf结尾的文件</span><br><span class="line">&#125;   // http层结束</span><br></pre></td></tr></table></figure><h3 id="二、部署nginx站点"><a href="#二、部署nginx站点" class="headerlink" title="二、部署nginx站点"></a>二、部署nginx站点</h3><p>nginx默认站点是Nginx目录下的html文件夹，这里可以从nginx.conf中查到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">        root   html;  #这里是默认的站点html文件夹，也就是              /opt/nginx1-12/html/文件夹下的内容</span><br><span class="line">        index  index.html index.htm; #站点首页文件名是index.html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要部署网站业务数据，只需要把开发好的程序全放到html目录下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@yc-virtual-machine /tmp 11:34:52]#ls /opt/nginx1-12/html/</span><br><span class="line">index.html  jssts.jpeg  lhy.mp4  man.jpg  wget-log</span><br></pre></td></tr></table></figure></p><p>至此，只需要通过域名/资源，即可访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.pyyuc.cn/index.html</span><br></pre></td></tr></table></figure></p><ul><li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;&lt;h3 id=&quot;一、nginx软件目录&quot;&gt;&lt;a href=&quot;#一、nginx软件目录&quot; class=&quot;headerlink&quot; title=&quot;一、nginx软件目录&quot;&gt;&lt;/a&gt;一、nginx软件目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@yc-virtual-machine /opt/nginx1-12 11:44:02]#ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  static  uwsgi_temp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;conf 存放nginx所有配置文件的目录,主要nginx.conf&lt;/li&gt;
&lt;li&gt;html 存放nginx默认站点的目录，如index.html、error.html等&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://sirxy.github.io/categories/nginx/"/>
    
    
      <category term="Nginx学习" scheme="http://sirxy.github.io/tags/Nginx%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>nginx简介、安装</title>
    <link href="http://sirxy.github.io/2019/04/02/nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%9301/"/>
    <id>http://sirxy.github.io/2019/04/02/nginx学习总结01/</id>
    <published>2019-04-02T10:01:56.000Z</published>
    <updated>2019-04-04T13:34:38.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="一、nginx出世"><a href="#一、nginx出世" class="headerlink" title="一、nginx出世"></a>一、nginx出世</h3><p>2004年10月4日，为俄罗斯知名门户站点而开发的Web服务程序 Nginx 横空出世。Nginx程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市场，但Nginx最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。<a id="more"></a></p><h3 id="二、nginx介绍"><a href="#二、nginx介绍" class="headerlink" title="二、nginx介绍"></a>二、nginx介绍</h3><ul><li>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是一个俄罗斯人lgor sysoev开发的，作者将源代码开源出来供全球使用。</li><li>nginx比它大哥apache性能改进许多，nginx占用的系统资源更少，支持更高的并发连接，有更高的访问效率。</li><li>nginx不但是一个优秀的web服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用。</li><li>安装更为简单，方便，灵活。</li><li>支持高并发，能支持几万并发连接</li><li>资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M</li><li>可以做http反向代理和负载均衡</li><li>支持异步网络i/o事件模型epoll<br>下面介绍nginx的安装与配置</li></ul><h3 id="三、安装配置nginx"><a href="#三、安装配置nginx" class="headerlink" title="三、安装配置nginx"></a>三、安装配置nginx</h3><h4 id="安装nginx前的依赖环境解决"><a href="#安装nginx前的依赖环境解决" class="headerlink" title="安装nginx前的依赖环境解决"></a>安装nginx前的依赖环境解决</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#执行第一条语句即可</span><br><span class="line">yum install gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</span><br><span class="line">#依赖简单介绍</span><br><span class="line">一. gcc 安装</span><br><span class="line">安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</span><br><span class="line">yum install gcc-c++</span><br><span class="line">二. PCRE pcre-devel 安装</span><br><span class="line">PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">三. zlib 安装</span><br><span class="line">zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">四. OpenSSL 安装</span><br><span class="line">OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。</span><br><span class="line">nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</span><br></pre></td></tr></table></figure><h4 id="编译安装nginx"><a href="#编译安装nginx" class="headerlink" title="编译安装nginx"></a>编译安装nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.下载源码包</span><br><span class="line">wget -c https://nginx.org/download/nginx-1.12.0.tar.gz</span><br><span class="line">2.解压缩源码</span><br><span class="line">tar -zxvf nginx-1.12.0.tar.gz</span><br><span class="line">3.配置，编译安装  开启nginx状态监测功能</span><br><span class="line">./configure --prefix=/opt/nginx112/ </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line">4.启动nginx，进入sbin目录,找到nginx启动命令</span><br><span class="line">cd sbin</span><br><span class="line">./nginx #启动</span><br><span class="line">./nginx -s stop #关闭</span><br><span class="line">./nginx -s reload #重新加载</span><br><span class="line">5.修改PATH</span><br><span class="line">PATH=$PATH:/opt/nginx112/</span><br></pre></td></tr></table></figure><ul><li>参考自：<a href="https://pythonav.com/wiki/detail/3/34/" target="_blank" rel="noopener">https://pythonav.com/wiki/detail/3/34/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;&lt;h3 id=&quot;一、nginx出世&quot;&gt;&lt;a href=&quot;#一、nginx出世&quot; class=&quot;headerlink&quot; title=&quot;一、nginx出世&quot;&gt;&lt;/a&gt;一、nginx出世&lt;/h3&gt;&lt;p&gt;2004年10月4日，为俄罗斯知名门户站点而开发的Web服务程序 Nginx 横空出世。Nginx程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市场，但Nginx最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://sirxy.github.io/categories/nginx/"/>
    
    
      <category term="Nginx学习" scheme="http://sirxy.github.io/tags/Nginx%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://sirxy.github.io/2019/02/13/hello-world/"/>
    <id>http://sirxy.github.io/2019/02/13/hello-world/</id>
    <published>2019-02-13T02:36:41.753Z</published>
    <updated>2019-04-04T13:28:09.866Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://sirxy.github.io/2018/11/19/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://sirxy.github.io/2018/11/19/Linux基础/</id>
    <published>2018-11-19T12:43:32.000Z</published>
    <updated>2019-04-04T13:34:59.677Z</updated>
    
    <content type="html"><![CDATA[<p>一、Linux与Windows的区别<br>体现在目录的结构和安全性上，Linux所有的命令是以文件形式存储的，在Linux系统当中一切皆为文件（常用的比如：普通文件、目录文件、链接文件、设备文件等）。<br><a id="more"></a><br>二、目录含义<br>/bin 存放普通用户的命令文件<br>/boot 存放系统启动文件<br>/cdrom 存放读取光盘<br>/dev 存放设备相关文件<br>/etc 存放配置文件<br>/home 家目录<br>/lib 库文件相关<br>/lib64 64位库文件<br>/lost+found 系统异常产生错误时，丢失文件放在这里<br>/media 媒体文件<br>/mnt 挂载目录<br>/opt 安装软件时的默认目录<br>/proc 内存中相关数据文件<br>/root root用户登录的家目录<br>/run 系统运行的时候用到的文件<br>/sbin 超级管理员运行的文件<br>/srv 服务启动之后需要访问的数据目录<br>/sys 系统文件<br>/tmp 临时文件<br>/usr 应用程序存放目录<br>/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件</p><p>三、相关命令<br>查看命令（目录结构、路径）：<br>.     当前路径<br>..  上一级路径<br>cd ..  回到上一级<br>cd  切换到家目录<br>cd ~  切换到家目录<br>cd - 回到上一个你操作的那一个目录<br>pwd 查看当前所在的目录是哪里<br>ls  查看当前文件夹里面有什么<br>    .bash_history 但凡是点开头的文件，都是隐藏文件<br>    -a  所有文件（包括隐藏文件）<br>    -l  以列表的形式呈现<br>    -h  可以让文件大小带上单位<br>ll 相当于ls -al<br>man 是帮助命令，比如：man ls或man cp<br>nano 内置自带的文本编辑器（编辑文件用的）<br>cat 查看文件内容<br>more 对于内容较多的情况下用more支持分页，空格下一页<br>head 加上-2是查看前几条<br>tail 加上-2是查看后几条<br>dmesg 查看系统接入设备信息<br>top 查看运行状态<br>sudo service network-manager restart 网络有线未托管<br>sudo apt-get install vim<br>操作命令（新建、复制粘贴剪切、删除）：<br>mkdir 要创建的文件夹名字<br>touch 要创建的文件名<br>ln -s 创建软链接，ln -s 指定你想要创建的连接  放到哪个目录下面，ln -s 需要使用绝对路径的方式来创建。<br>mv /路径/文件夹或文件 新名称  功能：既可以剪切也可以改名<br>cp 路径 路径（从哪里~到哪里去）<br>cp 默认只能够复制文件<br>cp -r 可以复制文件夹<br>cp -a 可以复制权限和所有属性<br>rm -rf 指定文件夹或者文件名称 功能：用于删除文件或者目录<br>查找命令（找文件、文件内容）：<br>find 搜索文件的命令<br>find 查找位置 -name 文件名<br>find    /     -iname index.php<br>grep 搜索文件里面符合条件的内容<br>grep “字符串” 文件名<br>grep  -i   “root”<br>grep  -v   “root”<br>挂载操作命令：<br>sudo fdisk -l         查看当前系统有哪些挂载设备<br>sudo mount 找到的设备路径 /mnt/cdrom           挂载<br>sudo umount /mnt/cdrom(umount + 挂载的目录)    取消挂载</p><p>四、权限结构<br>在Linux中，无论文件夹还是文件都是有权限的，通过在终端键入ls -l命令行可以看到每一行开始都有类似drwxrwxr-x的一串字符码，当中就包含有权限的标识。其中：第一位表示类型，即说明是文件夹(d)、文件(-)以及链接(l)中的哪一类型；后面的9位，每三位划分为一组作为权限位，从前往后这三个权限位分别标识所属主、所属组、其他用户的权限。<br>指定类型(dl-) 权限位1(rwx) 权限位2(rwx) 权限位3(rwx)，其中r=&gt;read w=&gt;write x=&gt;可执行，r =&gt; 4, w =&gt; 2, x =&gt; 1。<br>d rwx rwx r-x<br>文件类型-所属主 所属组 其他<br>   d     rwx     rwx    rwx<br>位数1,2,3 代表当前文件或者文件夹的所有者的权限设定:(所有者的权限  u,user)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>位数4,5,6 代表当前文件或者文件夹的所属组的权限设定:(所属组的权限 g ,group)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>位数7,8,9 代表其他用户对当前文件或者文件夹的的权限设定:(其他人的权限 o,other)<br>    1: r 或者 -  r表示可以读取  - 表示不可以读取<br>    2: w 或者 -  w表示可以写入  - 表示不可以写入<br>    3: x 或者 -  x表示可以执行  - 表示不可以执行<br>更改权限<br>rwx的任意组合共 8 种 情况：<br>rwx    =&gt; 7<br>rw-    =&gt; 6<br>r-x    =&gt; 5<br>r–    =&gt; 4<br>-wx    =&gt; 3<br>-w-    =&gt; 2<br>–x    =&gt; 1<br>—    =&gt; 0<br>其中r =&gt; 4, w =&gt; 2, x =&gt; 1。例如：根目录下默认的文件夹权限为755（rwx  r-x  r-x） ，根目录下默认的文件权限为644（rw-  r–  r–），所有权限为777（rwx  rwx  rwx）<br>关于权限更改的各种写法<br>chmod 755 1.txt<br>chmod -R 777 ceshi100(chmod -R 777 文件夹) # 递归更改这个文件夹里面的所有文件权限<br>chmod u+r,g-w,o+x 1.txt<br>chmod u=rwx 1.txt<br>其中：<br>u代表所有者   加一个r权限 (user)<br>g代表所属组   减一个w权限 (group)<br>o代表其他     加一个执行权限 (other)<br>=&gt;对于目录来讲<br>r   是否呈现里面的文件<br>w   是否可以在里面创建文件或文件夹<br>x   cd 切不进来  不能访问这个目录<br>=&gt;对于文件来讲<br>r  可以看到文件内容<br>w  可以更改删除文件及内容<br>x  是否可以执行这个文件 ./abc.sh</p><p>(*扩展)<br>sudo useradd a01    添加新用户账号<br>sudo passwd a01     为新用户设置密码<br>sudo su a01            切换用户账号<br>exit                  退出当前用户  </p><p><a href="http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/" target="_blank" rel="noopener">http://www.xuetangx.com/courses/course-v1:MITx+6_00_1x+sp/courseware/Week_1/videosequence:Lecture_1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Linux与Windows的区别&lt;br&gt;体现在目录的结构和安全性上，Linux所有的命令是以文件形式存储的，在Linux系统当中一切皆为文件（常用的比如：普通文件、目录文件、链接文件、设备文件等）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://sirxy.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://sirxy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python基础总结.md</title>
    <link href="http://sirxy.github.io/2018/11/17/Python%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-md/"/>
    <id>http://sirxy.github.io/2018/11/17/Python基础总结-md/</id>
    <published>2018-11-17T03:49:16.000Z</published>
    <updated>2019-04-04T13:34:03.392Z</updated>
    
    <content type="html"><![CDATA[<p>一、注释<br>1、 注释的排错性<br>    先注释一部分代码，然后执行另外一部分代码，查看报错，用于调试。<br>2、注释的注意点<br>    多行注释的嵌套：<br>        如果外面是三个单引号，则里面要用三个双引号；如果外面是三个双引号，则里面要用三个单引号。<br><a id="more"></a><br>二、变量<br>1、概念：可以改变的量，具体是指内存中的一段存储空间。<br>    house305 = “张三”<br>    print(house305)<br>    house305 = “李四”<br>    print(house305)<br>2、变量的三种声明方式：<br>    方式一<br>        a = 1<br>        b = 2<br>    方式二<br>        a, b = 1, 2<br>    方式三<br>        a = b = 3 (注意：这种方式的id(a) == id(b))</p><p>3、变量的命名规范：<br>字母数字下划线，首字母不能为数字。<br>严格区分大小写，且不能使用关键字。<br>变量命名有意义，且不能使用中文哦。<br>import keyword<br>print(keyword.kwlist) # [‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]<br>4、变量的交换<br>a = 3<br>b = 10<br>a, b = b, a<br>print(a, b) # 10 3</p><p>三、Python的六大数据类型<br>分为：Number型、容器类型（字符串型、列表型、元组型、集合型、字典型）。<br>(1)Number数字类型(int  float  bool  complex)<br>    ①Number类型之int 整型(正整数 0 负整数)<br>        intvar = 37<br>        print(intvar)</p><pre><code>    # type() 查看一个值的数据类型    res = type(intvar)    print(res) #&lt;class &apos;int&apos;&gt;    # id() 查看一个变量所指向值的地址    res = id(intvar)    print(res)  #10915520    # 二进制整型    intvar = 0b1010101    # 八进制整型    intvar = 0o127    # 十六进制整型    intvar = 0xFF    # 变量声明的第三种方式 特点    a = b = 89    res1 = id(a)    res2 = id(b)    print(res1)    print(res2)②Number类型之float 浮点型 （小数：1普通小数 2科学计数法表示的小数。例:a = 3e-5  #3e-05 ）    (1)表示方式一        floatvar = 3.14    (2)表示方式二        floatvar = 3.14e-2  # 小数点向左移动2位        floatvar = 3.14e04  # 小数点向右移动4位③Number类型之bool 布尔型 （True 真的 False 假的）    boolvar = True    boolvar = False    ④Number类型之complex 复数类型（实数+虚数 组成）    ‘&apos;&apos; 如果有一个数，它的平方是-1，那么这个数就是j        (科学家认为有，表达一个高精度的类型)    &apos;&apos;&apos;    (1) 表达方式一        complexvar = 3 + 4j        complexvar = 4j    (2)表达方式二        &apos;&apos;&apos; var1 = complex(实数,虚数)            通过complex强制转换成复数类型        &apos;&apos;&apos;        complexvar = complex(3, 5)</code></pre><p>（2）String字符串型<br>特征：可获取，不可修改的有序容器类型数据。</p><pre><code># errorstrvar=&quot;这是真的字符串&quot;strvar[-3] = &quot;假&quot;print(strvar)</code></pre><p>字符串有三种类型：通过单引号、双引号、三引号（可以支持跨行,不需要对单双引号进行转义）引起来的字符串。<br>转义字符：<br>    语法: \ + 字符<br>    (1)将无意义的字符变得有意义<br>    (2)将有意义的字符变得无意义<br>    例如：<br>        \n 或者 \r\n : 代表换行<br>        \t   : 代表一个tab缩进(水平制表符)<br>        \r   : 把\r后面的字符提到行首<br>        strvar = “处处\r蚊子咬”<br>        print(strvar)<br>元字符串：r+字符串：作用在于让转义字符失效，原型化输出<br>        strvar = r’夜来\n大狗熊’<br>        print(strvar)<br>        strvar = r”夜来\n大狗熊”<br>        print(strvar)<br>        strvar = r’’’夜来\n大狗熊’’’<br>        print(strvar)<br>        strvar = r”””夜来\n大狗\r熊\t”””<br>        print(strvar)<br>（3）List列表类型<br>特征：可获取，可修改de有序容器类型数据。<br>定义空列表：<br>    listvar = []<br>    print(listvar)<br>列表值的获取：<br>    listvar = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]<br>    res = listvar[1]<br>    res = listvar[len(listvar) - 1]<br>列表的修改：<br>    listvar = [‘a’, 14, 3,14, True, 4 + 3j]<br>    listvar[1] = “15”<br>（4）Tuple元组类型<br>特征：可获取，不可修改的有序的容器类型数据<br>定义空元组：<br>    tuplevar = ()<br>tuple类型的获取：<br>    tuplevar = (‘a’, ‘c’, ‘b’, ‘s’, 15 - 9j, False)<br>    res = tuplevar[-3]<br>tuple类型不支持修改</p><pre><code># errortuplevar[0] = 1234print(tuplevar)</code></pre><p>(5)Set集合类型<br>特征：自动去重，无序的容器类型数据。<br>作用：集合类型是用来做交集、差集、并集、补集操作的。<br>注意点：<br>无法通过索引来获取其中的数据。<br>    setvar = {True, “你好”, 34, 9.2, 3 + 4j}<br>    print(setvar)<br>    print(setvar[1]) # error<br>无法修改集合当中的值<br>    setvar[0] = “999” # error<br>    print(setvar)<br>单独定义一个{} 它代表的不是集合 而是字典<br>    var = {} # 空字典<br>    print(type(var)) #dict<br>    var = set() # 空集合<br>    print(type(var))<br>(6)Dict字典类型<br>特征：键值对存储的，无序容器类型数据。<br>dictvar = {‘top’: ‘程咬金’, ‘middle’: ‘貂蝉’, ‘bottm’: ‘鲁班七号’, ‘support’: ‘蔡文姬’, ‘jungle’: ‘韩信’}<br>字典的获取：通过键获取值<br>    res = dictvar[‘jungle’]<br>    print(res)<br>字典的修改<br>    dictvar[‘middle’] = ‘小乔’<br>    print(dictvar)</p><p>四、类型转换<br>–&gt;自动类型转换<br>当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高:bool、int、float、complex。<br>–&gt;强制类型转换<br>Number类型强制转换<br>通过int()、float()、complex()可以将整型、浮点型、布尔型以及纯数字字符串强转为对应的类型数据，而通过bool()则可以将Number类型数据和容器类型数据强转为bool类型数据。（扩展：布尔类型为假的时候，一共有10种情况：0, 0.0, False, 0j, ‘’, [], (), {}, set(), None）<br>容器类型强制转换<br>通过str()可以将Number类型和容器类型强制转为String型。<br>通过list()可以将字符串、列表、元组、集合、字典类型强制转换为List类型，把字典强转成列表,只要其中的键,忽略其中的值。<br>通过tuple()可以将容器类型数据强转为tuple类型数据，把字典强转成列表,只要其中的键,忽略其中的值。<br>通过set()可以将容器类型数据强制转换为集合类型数据，把字典强转成集合,只要其中的键,忽略其中的值。<br>dict()<br>使用 二级列表 或 二级元组   (二级集合语法上不错,但是无序,不建议使用)<br>‘’’强转成字典的条件：需要等长的二级容器’’’</p><h1 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h1><p>var1 = [(“a”: 1), (“b”, 2)]<br>var2 = [[‘a’: 3], [‘b’: 4]]<br>var3 = [(‘a’: 5), [‘b’: 6]]</p><h1 id="var4-‘a’-7-‘b’-8"><a href="#var4-‘a’-7-‘b’-8" class="headerlink" title="var4 = [{‘a’: 7}, {‘b’: 8}]"></a>var4 = [{‘a’: 7}, {‘b’: 8}]</h1><h1 id="res-print-var4"><a href="#res-print-var4" class="headerlink" title="res = print(var4)"></a>res = print(var4)</h1><p>print(res, type(res))</p><h1 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h1><p>var1 = ((‘a’, 1), (‘b’, 2))<br>var2 = ([‘a’, 3], [‘b’, 4])<br>var3 = ((‘a’, 5), [‘b’, 6])</p><h1 id="var4-‘a’-7-‘b’-8-切记不要使用"><a href="#var4-‘a’-7-‘b’-8-切记不要使用" class="headerlink" title="var4 = [{‘a’,7},{‘b’,8}] 切记不要使用"></a>var4 = [{‘a’,7},{‘b’,8}] 切记不要使用</h1><h1 id="res-dict-var4"><a href="#res-dict-var4" class="headerlink" title="res = dict(var4)"></a>res = dict(var4)</h1><p>print(res)</p><h1 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h1><p>var = {(‘a’, 1), (‘b’, 2)}<br>res = dict(var)<br>print(res)</p><p>五、以下数据类型存储规律仅对当前linux 64位的python3.x版本负责<br>–&gt;Number 部分<br>1.对于整型而言，-5~正无穷范围内的相同值 id一致<br>2.对于浮点数而言，非负数范围内的相同值 id一致<br>3.布尔值而言,值相同情况下，id一致<br>4.复数的id标识都不相同(在 实数+虚数 这样的结构中)<br>–&gt;容器类型部分<br>5.字符串而言，字符串值相同情况下，id一致<br>6.列表，元组，字典，集合无论什么情况 id标识都不同(但空元组的id标识一样)</p><p>六、Python运算符<br>(1)算数运算符:  + - <em> / // % **<br>(2)比较运算符:  &gt; &lt; &gt;= &lt;= == !=<br>(3)赋值运算符:  = += -= </em>= /= //= %= **=<br>(4)成员运算符:  in 和 not in (针对于容器型数据)<br>(5)身份运算符:  is 和 is not (检测两个数据在内存当中是否是同一个值)<br>(6)逻辑运算符:  and or not<br>True and print(1)<br>False and print(2) # 逻辑与短路<br>True or print(3) # 逻辑或短路<br>False or print(4)<br>(7)位运算符:    &amp; | ~ ^ &lt;&lt; &gt;&gt;<br>按位非是对补码进行操作的，每一位按位取反，包括高位符号位(注意：原码和补码之间的互相转换，符号位不动)<br>运算规律：公式：-(x + 1)<br>例如：<br>~19<br>补码:   00000000  10011<br>按位非: 11111111  01100<br>给补码求原码:<br>取反:1111111  10011<br>加1 :1111111  10100 (原码)<br>最终: -20<br>~(-19)<br>原码：11111111   10011<br>给原码求补码：<br>取反：11111111   01100<br>加一：11111111     01101<br>按位非运算：<br>      00000000   10010<br>最终：18<br>运算符的优先级：<br>一元运算符优先级 大于 二元运算符<br>    一元运算符（~按位非  -负号）<br>    例：~19只对一个数进行操作的运算符叫做一元运算符<br>    二元运算符<br>    例：1 + 2 对两个数 进行操作的运算符叫做二元运算符<br>运算符优先级最低的是 赋值运算符当中的=<br>运算符整体的优先顺序如下：<br>    算数运算符 &gt; 位运算符 &gt; 比较运算符 &gt; 赋值运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符</p><p>七、流程控制<br>大致分为三种控制结构：顺序结构、分支结构、循环结构。<br>分支结构分为：单项分支、双项分支、多项分支、巢状分支，通过if elif else关键字来构建。<br>循环结构分为while / for… in…，通过循环结构可以减少代码的冗余，提高执行效率。for…in…循环多用于遍历容器类型数据，而while则不能遍历无序的容器类型数据。在遍历字典时，默认遍历字典的键。遍历等长的二级列表：<br>    listvar = [[‘a’, ‘b’, ‘c’], [‘d’, ‘e’, ‘f’], [‘g’, ‘h’, ‘j’]]<br>    for i, j, k in listvar:<br>        print(i, j, k)<br>字符串的拼接：<br>–&gt;正常拼接：通过“+”来拼接。<br>    a = ‘1’<br>    b = ‘2’<br>    print(a + b)<br>–&gt;跨行拼接：通过\来衔接不同的多行。<br>    strvar = “123456”\<br>             “7890”<br>–&gt;重复拼接：通过字符 <em> 次数。<br>    strvar = ‘love’ </em> 10</p><p>pass用来占位 / break终止当前循环，只能用在循环当中 / continue跳过当前循环，后面的代码不执行，直接从下一次循环开始</p><p>八、函数<br>关于函数<br>(1)函数的含义:功能 (包裹一部分代码 实现某一个功能 达成某一个目的)<br>(2)函数特点:可以反复调用,提高代码的复用性,提高开发效率,便于维护管理<br>(3)函数基本格式<br>    def func():<br>        pass<br>(4)驼峰命名法：（便于程序员更为方便的阅读代码）<br>大驼峰命名法：MyCar（用在类的命名中）；<br>小驼峰命名法：myCar（一般用在函数命名中）；<br>普通情况下，一般用_来分割不同的词。</p><pre><code># 99乘法表的定义def multiplication99_table():    for i in range(1, 10):;        for j in range(1, i + 1):            print(&quot;%d*%d=%2d &quot; % (i, j, i*j), end=&quot;&quot;)        print()# 99乘法表的调用multiplication99_table()</code></pre><p>关于函数参数<br>(1)函数参数概念及分类<br>    函数参数:调用时需要传递的数据.<br>    函数参数大类分为形参和实参:<br>        形参: 在函数定义时，括号里面的参数，叫形参（形式参数）<br>        实参: 在函数调用时，括号里面的参数，叫实参（实际参数）<br>    形参与实参的关系:函数调用时,形参和实参个数需要一一对应<br>    形参种类:普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数<br>    实参种类:普通实参,关键字实参<br>  默认形参和关键字实参区别：默认形参和关键字实参写法上一样，只不过默认形参在函数的定义处，关键字实参在函数的调用处。<br>(2)收集参数:<br>    普通收集参数:在形参当中，<em>号后面的参数是收集参数，用于专门收集多余的普通参数,形成一个新的元组。语法:参数前面加</em>    例:*args。</p><pre><code># 例子：计算任意个数的累加和def my_sum(*args):    total = 0    for i in args:        total += i    print(total)my_sum(1, 2, 3, 77, 11)关键字收集参数:用于专门收集多余关键字实参的是关键字收集参数,形成一个新的字典。语法:参数前面加**    例:**kwargs。# 例子：任意参数的拼接def link_str(**kwargs):    print(kwargs)#{&apos;monitor&apos;:&apos;zhangbojin&apos;,&apos;zhangsan&apos;:&apos;zhangsan&apos;,&apos;school_beauty&apos;:&apos;wangitechui&apos;}    strvar1 = &apos;&apos;    strvar2 = &apos;&apos;    keydict = {&apos;monitor&apos;:&apos;班长&apos;,&apos;school_beauty&apos;:&apos;校花&apos;}    for key,val in kwargs.items():        if key in keydict:            strvar1 += keydict[key] + val + &apos;\n&apos;        else:             strvar2 += val    print(strvar1+&quot;今天结婚,喜结良缘&quot;+&quot;,到场的吃瓜群众是&quot;+strvar2)link_str(monitor=&quot; 张铂金 &quot;,school_beauty=&quot; 王铁锤 &quot;,zhangsan = &apos;张三&apos; )</code></pre><p>(3)命名关键字参数:定义时放在<em>号后面的参数,调用时强制必须指定关键字实参才能调。<br>在函数定义时，写在</em>后面的参数2是命名关键字参数（假定参数3是关键字收集参数）<br>语法:(*,x) x是命名关键字参数。<br>作用：在函数调用的时候，必须使用关键字实参进行调用**保证参数3不是关键字收集参数时，那么此刻参数2，参数3都是命名关键字参数</p><p>(4)关于<em>和**的 实参 调用:在调用时,容器类型数据前面加</em> 或者 <strong><br>在函数的调用处：例：func2(*listvar, </strong>dictvar)</p><ul><li>用在修改容器类型的数据，把容器里面的数据，一个一个拿出来，当成参数传递给函数<br>** 用在修饰字典类型的数据，意味着把字典中的{键: 值} =&gt;变成键=值,一个个当成参数赋值给函数调用<h1 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h1>  def func(a,b,*args,c,d):<pre><code>print(a,b)print(args)print(c)print(d)</code></pre>  func(1,2,3,4,5,c=6,d=999)<h1 id="号用法"><a href="#号用法" class="headerlink" title="*号用法"></a>*号用法</h1>  print(“======”)<br>  listvar = [1, 2, 3]<br>  func1(*listvar)<h1 id="func1-listvar-等价于-func1-1-2-3"><a href="#func1-listvar-等价于-func1-1-2-3" class="headerlink" title="func1(*listvar) 等价于 func1(1, 2, 3)"></a>func1(*listvar) 等价于 func1(1, 2, 3)</h1><h1 id="号用法-1"><a href="#号用法-1" class="headerlink" title="**号用法"></a>**号用法</h1>  dictvar = {‘d’: 4}<br>  func2(1, 2, 3, **dictvar)<h1 id="func2-1-2-3-dictvar-等价于-func2-1-2-3-d-4"><a href="#func2-1-2-3-dictvar-等价于-func2-1-2-3-d-4" class="headerlink" title="func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)"></a>func2(1,2,3,**dictvar) 等价于 func2(1,2,3,d=4)</h1><h1 id="函数的调用处"><a href="#函数的调用处" class="headerlink" title="函数的调用处"></a>函数的调用处</h1>  func2(<em>listvar,**dictvar)<br>(5)形参声明的位置顺序:<br>  普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt; 命名关键字参数 -&gt; 关键字收集参数<br>(6)对于任意函数，都可以通过 def func(</em>args, **kw) 来获取所有参数<h1 id="参数练习："><a href="#参数练习：" class="headerlink" title="参数练习："></a>参数练习：</h1>def f1(a, b, c=0, <em>args, **kwargs):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)<br>def f2(a, b, c=0, </em>, d, *kw):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘d =’, d, ‘kw =’, kw)<h1 id="以上两个函数-打印结果"><a href="#以上两个函数-打印结果" class="headerlink" title="以上两个函数 打印结果"></a>以上两个函数 打印结果</h1>#(一)<br>f1(1, 2) #a = 1 b = 2 c = 0 args = () kw = {}<br>f1(1, 2, c=3) #a = 1 b = 2 c = 3 args = () kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {}<br>f1(1, 2, 3, ‘a’, ‘b’, x=99) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99}<br>f2(1, 2, d=99, ext=None) #a = 1 b = 2 c = 0 d = 99 kw = {‘ext’: None}<br>#(二)<br>args = (1, 2, 3, 4)<br>kw = {‘d’: 99, ‘x’: ‘#’}<br>f1(*args, **kw)  #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}<h1 id="f1-1-2-3-4-d-99-x-’-’"><a href="#f1-1-2-3-4-d-99-x-’-’" class="headerlink" title="f1(1,2,3,4,d=99,x=’#’)"></a>f1(1,2,3,4,d=99,x=’#’)</h1>#(三)<br>myargs = (1, 2, 3)<br>mykw = {‘d’: 88, ‘x’: ‘#’}<br>f2(*myargs, **mykw) #a = 1 b = 2 c = 3 args = (4,) kw = {‘d’: 99, ‘x’: ‘#’}<h1 id="f2-1-2-3-d-88-x-’-’"><a href="#f2-1-2-3-d-88-x-’-’" class="headerlink" title="f2(1,2,3,d=88,x=’#’)"></a>f2(1,2,3,d=88,x=’#’)</h1>#(四)<br>def f1(a, b, c=0, *args,d,**kw):<br>  print(‘a =’, a, ‘b =’, b, ‘c =’, c, ‘args =’, args, ‘kw =’, kw)<br>  print(d)<br>f1(1,2,3, ‘a’, ‘b’,d=67, x=99,y=77) #a = 1 b = 2 c = 3 args = (‘a’, ‘b’) kw = {‘x’: 99, ‘y’: 77}</li></ul><p>return返回值<br>为这个函数返回一个结果 (return返回值可有可无 按照需求选择)注意:执行return语句之后,函数执行结束</p><p><strong><strong>doc</strong></strong>：<strong>doc</strong>或者help查看文档</p><p>全局变量、局部变量及其关键字的使用<br>– global   关键字:声明全局变量,作用在于修改全局变量<br>– nonlocal 关键字:声明函数内部的局部变量,作用在于修改局部变量(当前函数上一层的局部变量)</p><p>内部函数<br>(1)内部函数可以直接在函数外部调用么<br>(2)调用外部函数后,内部函数可以在函数外部调用吗<br>(3)内部函数可以在函数内部调用吗<br>(4)内部函数在函数内部调用时,是否有先后顺序</p><p>闭包<br>闭包的定义:<br>内函数使用外函数的局部变量，并且外函数将内函数返回出来的方法叫闭包,返回的内函数叫闭包函数。<br>闭包的特点:<br>外函数的临时变量会在将来的内部函数中用到,自己调用结束后会把外函数的临时变量与内函数绑定,不释放将来调用内函数的时候仍可使用外函数变量。<br>闭包的意义:<br>闭包可以优先使用外函数中的变量,并对闭包中的值起到了封装保护的作用.外部无法访问。</p><p>递归函数<br>递归的定义：自己调用自己就是递归函数。<br>递归的注意事项：<br>函数调用的过程就是开辟栈帧和释放栈帧的过程，调用结束时开辟栈帧空间，结束时释放（话外之意是不结束这层栈帧不释放）。<br>递归每次调用都会开辟一个栈帧，如果递归的层数过多，不建议使用，容易内存溢出。<br>每次开辟的栈帧空间，代码必须全部执行完毕之后才释放空间，在回到上一个栈帧执行没结束的代码。<br>如果使用递归，需要给予一个跳出的条件，不能无限递归。</p><p>匿名函数<br>实际上就是通过lambda表达式来书写的。一般只用来实现一些简单的函数功能，写法非常方便。</p><p>迭代器：<br>定义：能被next()函数调用并且不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）。<br>特征：迭代器会生成惰性序列，它通过计算把值依次地返回，一边循环一边计算而不是一次性得到所有数据。<br>优点：需要数据的时候，一次取一个，可以大大节省内存空间，而不是一股脑地把所有数据放进内存。‘<br>惰性序列：没有一次性的把所有数据都放在序列中，而是遍历一个放一个，这样的序列叫做惰性序列。<br>Iterable可迭代性    Iterator迭代器<br>range是可迭代对象<br>range和迭代器能够产生惰性序列</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、注释&lt;br&gt;1、 注释的排错性&lt;br&gt;    先注释一部分代码，然后执行另外一部分代码，查看报错，用于调试。&lt;br&gt;2、注释的注意点&lt;br&gt;    多行注释的嵌套：&lt;br&gt;        如果外面是三个单引号，则里面要用三个双引号；如果外面是三个双引号，则里面要用三个单引号。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python基础" scheme="http://sirxy.github.io/categories/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python基础" scheme="http://sirxy.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python OS模块常用方法总结</title>
    <link href="http://sirxy.github.io/2018/10/14/Python%20OS%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://sirxy.github.io/2018/10/14/Python OS模块常用方法总结/</id>
    <published>2018-10-14T10:42:29.000Z</published>
    <updated>2019-04-04T13:36:28.941Z</updated>
    
    <content type="html"><![CDATA[<p>os模块是与操作系统交互的一个接口。下面是关于对文件路径、文件夹等的相关操作及说明。<br><a id="more"></a></p><ul><li><p>操作               说明</p></li><li><p>os.getcwd()    得到当前工作目录，即当前Python脚本工作的目录路径</p></li><li>os.listdir()    返回指定目录下的所有文件和目录名</li><li>os.remove()    函数用来删除一个文件</li><li>os.removedirs(r”c\python”)    删除多个目录</li><li>os.path.isfile()    检验给出的路径是否是一个文件</li><li>os.path.isdir()    检验给出的路径是否是一个目录</li><li>os.path.isabs()    判断是否是绝对路径</li><li>os.path.exists()    检验给出的路径是否真地存</li><li>os.path.split()    返回一个路径的目录名和文件名</li><li>os.path.splitext()    分离扩展名</li><li>os.path.dirname()    获取路径名</li><li>os.path.basename()    获取文件名</li><li>os.system()    运行shell命令</li><li>os.getenv()与os.putenv()    读取和设置环境变量</li><li>os.linesep     给出当前平台使用的行终止符，Windows使用’rn’，Linux使用’n’而Mac使用’r’</li><li>os.name    指示你正在使用的平台，对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’</li><li>os.rename(old, new)    重命名：</li><li>os.makedirs(r”c：\python\test”)    创建多级目录</li><li>os.mkdir(“test”)    创建单个目录</li><li>os.stat(file)    获取文件属性</li><li>os.chmod(file)    修改文件权限与时间戳</li><li>os.exit()    终止当前进程</li><li>os.path.getsize(filename)    获取文件大小</li><li>os.mkdir(“file”)    创建目录</li><li>os.rename(“oldname”,”newname”)    重命名文件（目录）,文件或目录都是使用这条命令</li><li>os.remove(“file”)    删除文件</li><li>os.rmdir(“dir”)    删除目录, 只能删除空目录</li><li>os.chdir(“path”)    转换目录, 换路径</li><li>os.mknod(“test.txt”)    创建空文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;os模块是与操作系统交互的一个接口。下面是关于对文件路径、文件夹等的相关操作及说明。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://sirxy.github.io/categories/Python/"/>
    
      <category term="内置模块" scheme="http://sirxy.github.io/categories/Python/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="Python基础" scheme="http://sirxy.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML5/CSS3新特性、移除的元素及兼容问题</title>
    <link href="http://sirxy.github.io/2018/10/14/HTML5CSS3_001/"/>
    <id>http://sirxy.github.io/2018/10/14/HTML5CSS3_001/</id>
    <published>2018-10-14T03:32:35.000Z</published>
    <updated>2019-04-04T13:37:43.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有："><a href="#HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：" class="headerlink" title="HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有："></a>HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：</h3><a id="more"></a><ul><li>绘画canvas元素</li><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search<h3 id="CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。"><a href="#CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。" class="headerlink" title="CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。"></a>CSS3实现圆角、，阴影、对文字加特效，增加了更多的CSS选择器，多背景rgba，新的技术有webworker、websockt、Geolocation。</h3><h3 id="移除的元素包括："><a href="#移除的元素包括：" class="headerlink" title="移除的元素包括："></a>移除的元素包括：</h3></li><li>纯表现的元素  basefont、big、center、font、 s、strike、tt、u；</li><li>对可用性产生负面影响的元素  frame、frameset、noframes。<h3 id="浏览器兼容问题解决方案："><a href="#浏览器兼容问题解决方案：" class="headerlink" title="浏览器兼容问题解决方案："></a>浏览器兼容问题解决方案：</h3>IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式，当然最好的方式是直接使用成熟的框架：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt; </span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; </span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;&lt;h3 id=&quot;HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：&quot;&gt;&lt;a href=&quot;#HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：&quot; class=&quot;headerlink&quot; title=&quot;HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：&quot;&gt;&lt;/a&gt;HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、地理定位等功能的增加。新特性有：&lt;/h3&gt;
    
    </summary>
    
      <category term="html5" scheme="http://sirxy.github.io/categories/html5/"/>
    
      <category term="css3" scheme="http://sirxy.github.io/categories/html5/css3/"/>
    
    
      <category term="HTML5/CSS3" scheme="http://sirxy.github.io/tags/HTML5-CSS3/"/>
    
  </entry>
  
</feed>
